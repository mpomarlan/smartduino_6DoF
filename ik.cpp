/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2017-12-24 13:19:13.229638
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKcos(j[4]);
x6=IKsin(j[4]);
x7=IKsin(j[3]);
x8=IKcos(j[3]);
x9=IKsin(j[0]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((1.0)*x5);
x13=((0.01)*x0);
x14=((0.03)*x9);
x15=((0.15)*x2);
x16=((1.0)*x6);
x17=((0.15)*x0);
x18=((1.0)*x9);
x19=((1.0)*x2);
x20=((1.0)*x0);
x21=((0.15)*x8);
x22=(x3*x4);
x23=(x1*x3);
x24=(x7*x9);
x25=(x0*x4);
x26=(x2*x4);
x27=(x0*x1);
x28=(x4*x9);
x29=(x6*x8);
x30=(x18*x8);
x31=((1.0)*x23);
x32=((0.15)*x22);
x33=(x1*x15);
x34=(x1*x2*x9);
x35=(x19*x25);
x36=(x17*x23);
x37=(x15*x25);
x38=(x18*x26);
x39=((0.15)*x23*x9);
x40=(x15*x28);
x41=((((-1.0)*x31))+x26);
x42=(((x1*x19))+(((1.0)*x22)));
x43=(x33+x32);
x44=(x41*x8);
x45=(((x19*x27))+((x20*x22)));
x46=((-1.0)*x45);
x47=(((x18*x22))+((x1*x18*x2)));
x48=((-1.0)*x47);
x49=(x48*x8);
x50=(x47*x7);
x51=(x45*x7);
x52=((((-1.0)*x18*x7))+((x46*x8)));
x53=(((x0*x7))+x49);
x54=((((-1.0)*x12*x44))+(((-1.0)*x16*x42)));
x55=(((x16*(((((-1.0)*x35))+((x20*x23))))))+(((-1.0)*x12*x52)));
x56=((((-1.0)*x12*x53))+((x16*(((((-1.0)*x38))+((x18*x23)))))));
eerot[0]=(((x5*(((((-1.0)*x35))+((x0*x23))))))+((x52*x6)));
eerot[1]=(((x11*x55))+((x10*(((((-1.0)*x30))+x51)))));
eerot[2]=(((x11*((x30+(((-1.0)*x51))))))+((x10*x55)));
IkReal x57=((1.0)*x13);
eetrans[0]=((((-0.01)*x24))+(((-1.0)*x37))+((x8*(((((-1.0)*x1*x2*x57))+(((-1.0)*x22*x57))))))+((x5*(((((-1.0)*x36))+x37))))+(((-0.19)*x2*x27))+(((-0.19)*x0*x22))+(((0.03)*x0))+x36+(((0.17)*x25))+(((-0.03)*x27))+((x6*(((((-1.0)*x21*x46))+(((0.15)*x24)))))));
eerot[3]=(((x53*x6))+((x5*(((((-1.0)*x38))+((x23*x9)))))));
eerot[4]=(((x11*x56))+((x10*((((x0*x8))+x50)))));
eerot[5]=(((x11*(((((-1.0)*x20*x8))+(((-1.0)*x50))))))+((x10*x56)));
IkReal x58=(x22*x9);
eetrans[1]=((((-1.0)*x40))+(((-0.19)*x34))+((x6*(((((-1.0)*x17*x7))+(((-1.0)*x21*x48))))))+(((-0.19)*x58))+(((-1.0)*x1*x14))+x39+x14+(((0.17)*x28))+((x5*(((((-1.0)*x39))+x40))))+((x13*x7))+((x8*(((((-0.01)*x34))+(((-0.01)*x58)))))));
eerot[6]=((((-1.0)*x42*x5))+((x29*x41)));
eerot[7]=(((x11*x54))+((x10*x7*(((((-1.0)*x19*x4))+x31)))));
eerot[8]=(((x10*x54))+((x11*x41*x7)));
eetrans[2]=((0.03)+(((-1.0)*x43))+(((0.19)*x26))+(((0.03)*x4))+(((-0.19)*x23))+((x29*(((((-1.0)*x15*x4))+(((0.15)*x23))))))+((x43*x5))+((x8*(((((-0.01)*x23))+(((0.01)*x26))))))+(((0.17)*x1)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=(px+(((0.15)*r00)));
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=(py+(((0.15)*r10)));
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.03)+(((0.15)*r20))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x59=((1.0)*px);
IkReal x60=((1.0)*pz);
IkReal x61=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x61))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x60)));
rxp0_2=((((-1.0)*r10*x59))+((py*r00)));
rxp1_0=((((-1.0)*r21*x61))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x60)));
rxp1_2=((((-1.0)*r11*x59))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x61)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x60)));
rxp2_2=((((-1.0)*r12*x59))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x62=(rxp2_2+(((-0.01)*r21)));
IkReal x63=((0.01)*r21);
IkReal x64=((0.0006)*r00);
IkReal x65=((0.38)*rxp2_1);
IkReal x66=((0.0038)*r11);
IkReal x67=((0.3)*npz);
IkReal x68=((0.06)*px);
IkReal x69=((0.009)*r02);
IkReal x70=((0.0114)*r22);
IkReal x71=((1.0)*pp);
IkReal x72=((0.02)*npx);
IkReal x73=((0.06)*py);
IkReal x74=((0.0006)*r10);
IkReal x75=((0.0038)*r01);
IkReal x76=((0.38)*rxp2_0);
IkReal x77=((0.009)*r12);
IkReal x78=((0.0076)*r10);
IkReal x79=((0.04)*npy);
IkReal x80=((0.0012)*r01);
IkReal x81=((4.0)*rxp1_2);
IkReal x82=((2.0)*rxp0_2);
IkReal x83=((0.6)*npx);
IkReal x84=((0.76)*rxp0_1);
IkReal x85=((0.04)*npz);
IkReal x86=((0.018)*r00);
IkReal x87=((0.0012)*r02);
IkReal x88=((0.0228)*r20);
IkReal x89=((0.018)*r10);
IkReal x90=((0.0012)*r12);
IkReal x91=((0.76)*rxp0_0);
IkReal x92=((0.036)*r01);
IkReal x93=((1.2)*npy);
IkReal x94=((1.52)*rxp1_1);
IkReal x95=((0.0456)*r21);
IkReal x96=((1.0)*rxp2_2);
IkReal x97=((0.0076)*r00);
IkReal x98=((0.0012)*r11);
IkReal x99=((-0.02)*r20);
IkReal x100=(rxp2_2+x63);
IkReal x101=((-2.0)*rxp0_2);
IkReal x102=(x63+(((-1.0)*x96)));
IkReal x103=(x97+(((-1.0)*x98)));
IkReal x104=((-0.0298)+x69);
IkReal x105=((-0.0298)+x65);
IkReal x106=(x98+x97);
IkReal x107=((((-0.036)*r11))+(((-1.52)*rxp1_0)));
IkReal x108=((((-1.0)*x96))+(((-1.0)*x63)));
IkReal x109=(x83+x86);
IkReal x110=(x88+x85);
IkReal x111=(x74+x73);
IkReal x112=(x77+x76);
IkReal x113=(x66+x68);
IkReal x114=(x72+x70);
IkReal x115=(x71+x69);
IkReal x116=(x89+x91);
IkReal x117=(x70+x66);
IkReal x118=(x83+x84);
IkReal x119=(x79+x78);
IkReal x120=(x70+x68);
IkReal x121=(x71+x65);
IkReal x122=(x64+x67);
IkReal x123=(x116+(((-1.0)*x90)));
IkReal x124=((((-1.0)*x116))+(((-1.0)*x90)));
IkReal x125=(x72+x65+x67);
IkReal x126=((((-1.0)*x74))+(((-1.0)*x112))+x75+x73);
IkReal x127=((((-1.0)*x75))+(((-1.0)*x112))+x111);
IkReal x128=((((-1.0)*x74))+(((-1.0)*x75))+x112+x73);
IkReal x129=(x112+x111+x75);
op[0]=x62;
op[1]=x62;
op[2]=x99;
op[3]=x99;
op[4]=x100;
op[5]=x100;
op[6]=((((-1.0)*x115))+(((-1.0)*x117))+x105+x72+x67+x68+(((-1.0)*x64)));
op[7]=x126;
op[8]=((((-1.0)*x119))+x80);
op[9]=x106;
op[10]=((((-1.0)*x114))+(((-1.0)*x115))+x122+x113+x105);
op[11]=x127;
op[12]=x126;
op[13]=((((-1.0)*x121))+(((-1.0)*x120))+x122+x104+x72+x66);
op[14]=x106;
op[15]=((((-1.0)*x79))+x78+(((-1.0)*x80)));
op[16]=x127;
op[17]=((((-1.0)*x113))+(((-1.0)*x114))+(((-1.0)*x121))+x104+x67+(((-1.0)*x64)));
op[18]=0;
op[19]=x62;
op[20]=0;
op[21]=x99;
op[22]=0;
op[23]=x100;
op[24]=x101;
op[25]=x101;
op[26]=x81;
op[27]=x81;
op[28]=x82;
op[29]=x82;
op[30]=((((-1.0)*x118))+x110+x86+(((-1.0)*x87)));
op[31]=x123;
op[32]=(x93+x94+(((-1.0)*x95))+(((-1.0)*x92)));
op[33]=x107;
op[34]=(x118+x85+(((-1.0)*x88))+(((-1.0)*x87))+(((-1.0)*x86)));
op[35]=x124;
op[36]=x123;
op[37]=((((-1.0)*x109))+x110+x87+x84);
op[38]=x107;
op[39]=(x93+x92+(((-1.0)*x94))+(((-1.0)*x95)));
op[40]=x124;
op[41]=(x109+x87+x85+(((-1.0)*x88))+(((-1.0)*x84)));
op[42]=0;
op[43]=x101;
op[44]=0;
op[45]=x81;
op[46]=0;
op[47]=x82;
op[48]=x108;
op[49]=x108;
op[50]=x99;
op[51]=x99;
op[52]=x102;
op[53]=x102;
op[54]=((((-1.0)*x72))+(((-1.0)*x121))+x120+x104+x64+(((-1.0)*x67))+(((-1.0)*x66)));
op[55]=x129;
op[56]=((((-1.0)*x78))+x79+(((-1.0)*x80)));
op[57]=x103;
op[58]=((((-1.0)*x121))+(((-1.0)*x122))+x113+x114+x104);
op[59]=x128;
op[60]=x129;
op[61]=((((-1.0)*x72))+(((-1.0)*x115))+(((-1.0)*x122))+x117+x105+(((-1.0)*x68)));
op[62]=x103;
op[63]=(x119+x80);
op[64]=x128;
op[65]=((((-1.0)*x113))+(((-1.0)*x115))+x114+x105+x64+(((-1.0)*x67)));
op[66]=0;
op[67]=x108;
op[68]=0;
op[69]=x99;
op[70]=0;
op[71]=x102;
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x130=htj4*htj4;
CheckValue<IkReal> x131=IKPowWithIntegerCheck(((1.0)+x130),-1);
if(!x131.valid){
continue;
}
cj4array[numsolutions]=((x131.value)*(((1.0)+(((-1.0)*x130)))));
CheckValue<IkReal> x132=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x132.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x132.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x133=htj5*htj5;
CheckValue<IkReal> x134=IKPowWithIntegerCheck(((1.0)+x133),-1);
if(!x134.valid){
continue;
}
cj5array[numsolutions]=((x134.value)*(((1.0)+(((-1.0)*x133)))));
CheckValue<IkReal> x135=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x135.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x135.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x136=htj0*htj0;
CheckValue<IkReal> x137=IKPowWithIntegerCheck(((1.0)+x136),-1);
if(!x137.valid){
continue;
}
cj0array[numsolutions]=((x137.value)*(((1.0)+(((-1.0)*x136)))));
CheckValue<IkReal> x138=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x138.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x138.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[3];
IkReal x139=((1.0)*cj0);
IkReal x140=((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5)));
j3eval[0]=x140;
j3eval[1]=IKsign(x140);
j3eval[2]=((IKabs((((cj0*cj4*cj5*r20))+(((-1.0)*cj4*r21*sj5*x139))+((cj0*r22*sj4)))))+(IKabs(((((-1.0)*r20*sj5*x139))+(((-1.0)*cj5*r21*x139))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
IkReal x141=((1.0)*sj5);
IkReal x142=(r20*sj0);
IkReal x143=((1.0)*r21*sj0);
IkReal x144=(((cj5*r10*sj4))+(((-1.0)*r11*sj4*x141))+(((-1.0)*cj4*r12)));
j3eval[0]=x144;
j3eval[1]=((IKabs((((cj4*cj5*x142))+((r22*sj0*sj4))+(((-1.0)*cj4*r21*sj0*x141)))))+(IKabs(((((-1.0)*x141*x142))+(((-1.0)*cj5*x143))))));
j3eval[2]=IKsign(x144);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x145=(((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)));
j3eval[0]=x145;
j3eval[1]=IKsign(x145);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x146=((1.0)*cj5);
IkReal x147=((1.0)*sj5);
IkReal x148=(((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*r20*sj4*x146)));
j3eval[0]=x148;
j3eval[1]=((IKabs(((((-1.0)*cj4*r01*x147))+((r02*sj4))+((cj4*cj5*r00)))))+(IKabs(((((-1.0)*r01*x146))+(((-1.0)*r00*x147))))));
j3eval[2]=IKsign(x148);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x149=((1.0)*sj5);
IkReal x150=((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*x149)));
j3eval[0]=x150;
j3eval[1]=((IKabs((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*r21*x149)))))+(IKabs(((((-1.0)*cj5*r21))+(((-1.0)*r20*x149))))));
j3eval[2]=IKsign(x150);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x151=cj4*cj4;
IkReal x152=cj5*cj5;
IkReal x153=r10*r10;
IkReal x154=r11*r11;
IkReal x155=r12*r12;
IkReal x156=(r11*sj5);
IkReal x157=((1.0)*r10);
IkReal x158=(r12*sj4);
IkReal x159=((1.0)*x153);
IkReal x160=((2.0)*cj5*r10);
IkReal x161=(x152*x154);
IkReal x162=((((-1.0)*x159))+((x151*x161))+((x152*x153))+((x151*x155))+(((-1.0)*x161))+(((-1.0)*x151*x154))+(((-1.0)*x155))+((x151*x156*x160))+(((-1.0)*cj4*x158*x160))+(((-1.0)*x151*x152*x159))+(((2.0)*cj4*x156*x158))+(((-1.0)*x156*x160)));
j3eval[0]=x162;
j3eval[1]=IKsign(x162);
j3eval[2]=((IKabs(((((-1.0)*cj5*r11))+(((-1.0)*sj5*x157)))))+(IKabs((((cj4*x156))+(((-1.0)*x158))+(((-1.0)*cj4*cj5*x157))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x163=cj4*cj4;
IkReal x164=cj5*cj5;
IkReal x165=r10*r10;
IkReal x166=r11*r11;
IkReal x167=r12*r12;
IkReal x168=(r11*sj5);
IkReal x169=((1.0)*cj5);
IkReal x170=(r12*sj4);
IkReal x171=((1.0)*x165);
IkReal x172=((2.0)*cj5*r10);
IkReal x173=(x164*x166);
CheckValue<IkReal> x174=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*x170*x172))+(((-1.0)*x163*x166))+(((-1.0)*x171))+(((-1.0)*x163*x164*x171))+(((-1.0)*x173))+(((2.0)*cj4*x168*x170))+(((-1.0)*x167))+((x164*x165))+((x163*x168*x172))+(((-1.0)*x168*x172))+((x163*x173))+((x163*x167)))),-1);
if(!x174.valid){
continue;
}
CheckValue<IkReal> x175 = IKatan2WithCheck(IkReal((((cj4*x168))+(((-1.0)*x170))+(((-1.0)*cj4*r10*x169)))),IkReal(((((-1.0)*r10*sj5))+(((-1.0)*r11*x169)))),IKFAST_ATAN2_MAGTHRESH);
if(!x175.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x174.value)))+(x175.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x176=IKsin(j3);
IkReal x177=IKcos(j3);
IkReal x178=(r10*sj5);
IkReal x179=(cj4*sj5);
IkReal x180=(cj5*r11);
IkReal x181=(cj4*cj5);
IkReal x182=(r12*sj4);
IkReal x183=((1.0)*x177);
IkReal x184=((1.0)*x176);
evalcond[0]=(((x176*x180))+((x176*x178))+(((-1.0)*r10*x181*x183))+((r11*x177*x179))+(((-1.0)*x182*x183)));
evalcond[1]=((((-1.0)*r22*sj4*x184))+(((-1.0)*cj5*r21*x183))+((r21*x176*x179))+(((-1.0)*r20*x181*x184))+(((-1.0)*r20*sj5*x183)));
evalcond[2]=((((-1.0)*r02*sj4*x184))+(((-1.0)*r00*x181*x184))+((r01*x176*x179))+(((-1.0)*r00*sj5*x183))+(((-1.0)*cj5*r01*x183)));
evalcond[3]=((1.0)+(((-1.0)*x178*x183))+((r11*x176*x179))+(((-1.0)*x180*x183))+(((-1.0)*r10*x181*x184))+(((-1.0)*x182*x184)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x185=((12.0)*px);
IkReal x186=((12.0)*pz);
IkReal x187=(r01*sj5);
IkReal x188=((0.12)*cj4);
IkReal x189=((0.76)*sj4);
IkReal x190=((0.12)*sj4);
IkReal x191=(cj4*r02);
IkReal x192=((0.04)*sj4);
IkReal x193=(cj4*r22);
IkReal x194=(cj5*r20);
IkReal x195=((0.04)*cj4);
IkReal x196=(cj5*r00);
IkReal x197=(r21*sj5);
IkReal x198=((1.8)*sj4);
IkReal x199=((0.6)*sj4);
IkReal x200=((2.28)*sj4);
IkReal x201=((2.28)*x191);
IkReal x202=(sj4*x196);
IkReal x203=(sj4*x194);
IkReal x204=(x187*x188);
IkReal x205=(x196*x198);
IkReal x206=(x194*x200);
IkReal x207=(x187*x200);
IkReal x208=(x194*x198);
IkReal x209=(x188*x197);
IkReal x210=(x185+x206+x205+x204);
IkReal x211=(x186+x207+x201+x209+x208);
IkReal x212=(((x196*x200))+(((1.8)*x193))+((x188*x194))+((r22*x190))+((x197*x198)));
IkReal x213=((((2.28)*x193))+(((1.8)*x191))+((x187*x198))+((x188*x196))+((x197*x200))+((r02*x190)));
j1eval[0]=((6.4)+(IKabs(((0.68)+(((-1.0)*x194*x195))+(((-1.0)*x189*x196))+(((4.0)*pz))+((x187*x189))+(((0.76)*x191))+(((-1.0)*r22*x192))+(((-1.0)*x197*x199))+((x195*x197))+((x194*x199))+(((-0.6)*x193)))))+(IKabs(((0.68)+x211+(((-1.0)*x212)))))+(IKabs(((-0.24)+(((-0.76)*x193))+(((-1.0)*x195*x196))+((x187*x195))+(((-1.0)*x189*x197))+(((4.0)*px))+((x189*x194))+((x196*x199))+(((-1.0)*x187*x199))+(((-1.0)*r02*x192))+(((-0.6)*x191)))))+(IKabs(((-0.68)+x211+(((-1.0)*x212)))))+(IKabs(((-0.24)+x210+(((-1.0)*x213)))))+(IKabs(((-0.48)+x210+(((-1.0)*x213))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x214=((12.0)*px);
IkReal x215=((4.0)*px);
IkReal x216=(r02*sj4);
IkReal x217=(cj4*r02);
IkReal x218=(cj4*r22);
IkReal x219=(cj5*sj4);
IkReal x220=(cj4*r01*sj5);
IkReal x221=(cj4*cj5*r00);
IkReal x222=(r01*sj4*sj5);
IkReal x223=(r21*sj4*sj5);
IkReal x224=((0.12)*x220);
IkReal x225=((1.8)*r00*x219);
IkReal x226=((2.28)*r20*x219);
IkReal x227=((0.76)*r20*x219);
IkReal x228=((0.6)*r00*x219);
IkReal x229=((0.04)*x220);
IkReal x230=(x214+x225+x224+x226);
IkReal x231=(x215+x229+x228+x227);
IkReal x232=((((0.12)*x216))+(((2.28)*x218))+(((1.8)*x222))+(((0.12)*x221))+(((2.28)*x223))+(((1.8)*x217)));
IkReal x233=((((0.04)*x221))+(((0.6)*x222))+(((0.76)*x223))+(((0.04)*x216))+(((0.76)*x218))+(((0.6)*x217)));
op[0]=((-0.24)+(((-1.0)*x233))+x231);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x232))+x230);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x232))+x230);
op[5]=-1.36;
op[6]=((((-1.0)*x233))+x231);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x234=((12.0)*pz);
IkReal x235=((4.0)*pz);
IkReal x236=(cj5*sj4);
IkReal x237=(sj4*sj5);
IkReal x238=(r22*sj4);
IkReal x239=(cj4*r02);
IkReal x240=(cj4*r22);
IkReal x241=((2.28)*x239);
IkReal x242=((0.76)*x239);
IkReal x243=((0.6)*x240);
IkReal x244=((0.04)*x238);
IkReal x245=(cj4*cj5*r20);
IkReal x246=(cj4*r21*sj5);
IkReal x247=((2.28)*r01*x237);
IkReal x248=((1.8)*r20*x236);
IkReal x249=((0.12)*x246);
IkReal x250=((0.6)*r20*x236);
IkReal x251=((0.76)*r01*x237);
IkReal x252=((0.04)*x246);
IkReal x253=((0.04)*x245);
IkReal x254=((0.6)*r21*x237);
IkReal x255=((0.76)*r00*x236);
IkReal x256=(x234+x241+x247+x249+x248);
IkReal x257=(x250+x251+x252+x235+x242);
IkReal x258=((((0.12)*x245))+(((1.8)*r21*x237))+(((0.12)*x238))+(((1.8)*x240))+(((2.28)*r00*x236)));
IkReal x259=(x254+x255+x253+x243+x244);
j1evalpoly[0]=((-0.68)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.68)+x257+(((-1.0)*x259))))))+(((-0.24)*htj1))+(((-0.24)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.68)+x256+(((-1.0)*x258))))))+(((-0.48)*(htj1*htj1*htj1)))+x257+(((htj1*htj1)*(((-0.68)+x256+(((-1.0)*x258))))))+(((-1.0)*x259)));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x260=((1.0)*cj1);
IkReal x261=(cj4*r22);
IkReal x262=(cj5*sj4);
IkReal x263=(sj4*sj5);
IkReal x264=((1.0)*sj1);
IkReal x265=(cj4*r02);
if( IKabs((((cj1*r20*x262))+(((-1.0)*r21*x260*x263))+(((-1.0)*r01*x263*x264))+((r00*sj1*x262))+(((-1.0)*x264*x265))+(((-1.0)*x260*x261)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x265))+(((-1.0)*r21*x263*x264))+(((-1.0)*x261*x264))+((r20*sj1*x262))+((cj1*r01*x263))+(((-1.0)*r00*x260*x262)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r20*x262))+(((-1.0)*r21*x260*x263))+(((-1.0)*r01*x263*x264))+((r00*sj1*x262))+(((-1.0)*x264*x265))+(((-1.0)*x260*x261))))+IKsqr((((cj1*x265))+(((-1.0)*r21*x263*x264))+(((-1.0)*x261*x264))+((r20*sj1*x262))+((cj1*r01*x263))+(((-1.0)*r00*x260*x262))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj1*r20*x262))+(((-1.0)*r21*x260*x263))+(((-1.0)*r01*x263*x264))+((r00*sj1*x262))+(((-1.0)*x264*x265))+(((-1.0)*x260*x261))), (((cj1*x265))+(((-1.0)*r21*x263*x264))+(((-1.0)*x261*x264))+((r20*sj1*x262))+((cj1*r01*x263))+(((-1.0)*r00*x260*x262))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x266=IKcos(j2);
IkReal x267=IKsin(j2);
IkReal x268=((0.15)*sj1);
IkReal x269=((1.0)*cj3);
IkReal x270=(r02*sj4);
IkReal x271=(cj5*r00);
IkReal x272=(r01*sj5);
IkReal x273=((1.0)*sj4);
IkReal x274=(cj5*sj3);
IkReal x275=((1.0)*sj1);
IkReal x276=(sj3*sj5);
IkReal x277=((1.0)*cj4);
IkReal x278=((0.01)*cj4);
IkReal x279=((0.19)*sj1);
IkReal x280=(r21*sj5);
IkReal x281=(r22*sj4);
IkReal x282=(cj1*x266);
IkReal x283=(cj3*cj4*sj5);
IkReal x284=(cj1*x267);
IkReal x285=(cj4*cj5*r20);
IkReal x286=(x266*x275);
IkReal x287=((1.0)*x284);
IkReal x288=(x287+x286);
evalcond[0]=((((-1.0)*x272*x273))+x282+(((-1.0)*r02*x277))+(((-1.0)*x267*x275))+((sj4*x271)));
evalcond[1]=(((cj5*r20*sj4))+(((-1.0)*r22*x277))+(((-1.0)*x288))+(((-1.0)*x273*x280)));
evalcond[2]=(((r21*x274))+(((-1.0)*x282))+(((-1.0)*x269*x281))+(((-1.0)*x269*x285))+((sj1*x267))+((cj3*cj4*x280))+((r20*x276)));
evalcond[3]=(((cj3*cj4*x272))+(((-1.0)*x269*x270))+((r01*x274))+(((-1.0)*x288))+(((-1.0)*cj4*x269*x271))+((r00*x276)));
evalcond[4]=((((-0.15)*x284))+(((0.17)*cj1))+(((0.01)*x281))+(((0.03)*sj1))+(((-1.0)*pz))+((cj5*r20*x278))+(((-1.0)*x266*x268))+((x267*x279))+(((-1.0)*x278*x280))+(((-0.19)*x282)));
evalcond[5]=((0.03)+(((-1.0)*x272*x278))+((x271*x278))+(((0.17)*sj1))+(((-1.0)*px))+(((0.15)*x282))+(((-1.0)*x267*x268))+(((-1.0)*x266*x279))+(((-0.03)*cj1))+(((0.01)*x270))+(((-0.19)*x284)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x289=((1.0)*sj5);
CheckValue<IkReal> x290 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x289))+(((-1.0)*cj5*r21)))),IkReal((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*r21*x289)))),IKFAST_ATAN2_MAGTHRESH);
if(!x290.valid){
continue;
}
CheckValue<IkReal> x291=IKPowWithIntegerCheck(IKsign(((((-1.0)*r01*sj4*x289))+(((-1.0)*cj4*r02))+((cj5*r00*sj4)))),-1);
if(!x291.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x290.value)+(((1.5707963267949)*(x291.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x292=IKsin(j3);
IkReal x293=IKcos(j3);
IkReal x294=(r10*sj5);
IkReal x295=(cj4*sj5);
IkReal x296=(cj5*r11);
IkReal x297=(cj4*cj5);
IkReal x298=(r12*sj4);
IkReal x299=((1.0)*x293);
IkReal x300=((1.0)*x292);
evalcond[0]=((((-1.0)*x298*x299))+((r11*x293*x295))+(((-1.0)*r10*x297*x299))+((x292*x296))+((x292*x294)));
evalcond[1]=((((-1.0)*r22*sj4*x300))+(((-1.0)*cj5*r21*x299))+((r21*x292*x295))+(((-1.0)*r20*sj5*x299))+(((-1.0)*r20*x297*x300)));
evalcond[2]=((((-1.0)*r00*x297*x300))+(((-1.0)*cj5*r01*x299))+((r01*x292*x295))+(((-1.0)*r02*sj4*x300))+(((-1.0)*r00*sj5*x299)));
evalcond[3]=((1.0)+(((-1.0)*x298*x300))+((r11*x292*x295))+(((-1.0)*x296*x299))+(((-1.0)*r10*x297*x300))+(((-1.0)*x294*x299)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x301=((12.0)*px);
IkReal x302=((12.0)*pz);
IkReal x303=(r01*sj5);
IkReal x304=((0.12)*cj4);
IkReal x305=((0.76)*sj4);
IkReal x306=((0.12)*sj4);
IkReal x307=(cj4*r02);
IkReal x308=((0.04)*sj4);
IkReal x309=(cj4*r22);
IkReal x310=(cj5*r20);
IkReal x311=((0.04)*cj4);
IkReal x312=(cj5*r00);
IkReal x313=(r21*sj5);
IkReal x314=((1.8)*sj4);
IkReal x315=((0.6)*sj4);
IkReal x316=((2.28)*sj4);
IkReal x317=((2.28)*x307);
IkReal x318=(sj4*x312);
IkReal x319=(sj4*x310);
IkReal x320=(x303*x304);
IkReal x321=(x312*x314);
IkReal x322=(x310*x316);
IkReal x323=(x303*x316);
IkReal x324=(x310*x314);
IkReal x325=(x304*x313);
IkReal x326=(x301+x320+x321+x322);
IkReal x327=(x302+x324+x325+x323+x317);
IkReal x328=(((x304*x310))+((r22*x306))+((x312*x316))+(((1.8)*x309))+((x313*x314)));
IkReal x329=(((x304*x312))+(((2.28)*x309))+(((1.8)*x307))+((r02*x306))+((x303*x314))+((x313*x316)));
j1eval[0]=((6.4)+(IKabs(((-0.68)+(((-1.0)*x328))+x327)))+(IKabs(((0.68)+(((-1.0)*r22*x308))+((x310*x315))+(((-1.0)*x313*x315))+(((-1.0)*x310*x311))+(((0.76)*x307))+(((4.0)*pz))+((x303*x305))+(((-1.0)*x305*x312))+(((-0.6)*x309))+((x311*x313)))))+(IKabs(((-0.48)+(((-1.0)*x329))+x326)))+(IKabs(((-0.24)+(((-1.0)*x329))+x326)))+(IKabs(((-0.24)+((x305*x310))+((x312*x315))+(((4.0)*px))+(((-0.76)*x309))+(((-1.0)*x303*x315))+(((-1.0)*r02*x308))+(((-1.0)*x305*x313))+(((-0.6)*x307))+((x303*x311))+(((-1.0)*x311*x312)))))+(IKabs(((0.68)+(((-1.0)*x328))+x327))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x330=((12.0)*px);
IkReal x331=((4.0)*px);
IkReal x332=(r02*sj4);
IkReal x333=(cj4*r02);
IkReal x334=(cj4*r22);
IkReal x335=(cj5*sj4);
IkReal x336=(cj4*r01*sj5);
IkReal x337=(cj4*cj5*r00);
IkReal x338=(r01*sj4*sj5);
IkReal x339=(r21*sj4*sj5);
IkReal x340=((0.12)*x336);
IkReal x341=((1.8)*r00*x335);
IkReal x342=((2.28)*r20*x335);
IkReal x343=((0.76)*r20*x335);
IkReal x344=((0.6)*r00*x335);
IkReal x345=((0.04)*x336);
IkReal x346=(x330+x342+x340+x341);
IkReal x347=(x331+x343+x344+x345);
IkReal x348=((((0.12)*x337))+(((0.12)*x332))+(((2.28)*x339))+(((2.28)*x334))+(((1.8)*x333))+(((1.8)*x338)));
IkReal x349=((((0.76)*x334))+(((0.76)*x339))+(((0.04)*x332))+(((0.04)*x337))+(((0.6)*x333))+(((0.6)*x338)));
op[0]=((-0.24)+x347+(((-1.0)*x349)));
op[1]=-1.36;
op[2]=((-0.48)+x346+(((-1.0)*x348)));
op[3]=-2.72;
op[4]=((-0.24)+x346+(((-1.0)*x348)));
op[5]=-1.36;
op[6]=(x347+(((-1.0)*x349)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x350=((12.0)*pz);
IkReal x351=((4.0)*pz);
IkReal x352=(cj5*sj4);
IkReal x353=(sj4*sj5);
IkReal x354=(r22*sj4);
IkReal x355=(cj4*r02);
IkReal x356=(cj4*r22);
IkReal x357=((2.28)*x355);
IkReal x358=((0.76)*x355);
IkReal x359=((0.6)*x356);
IkReal x360=((0.04)*x354);
IkReal x361=(cj4*cj5*r20);
IkReal x362=(cj4*r21*sj5);
IkReal x363=((2.28)*r01*x353);
IkReal x364=((1.8)*r20*x352);
IkReal x365=((0.12)*x362);
IkReal x366=((0.6)*r20*x352);
IkReal x367=((0.76)*r01*x353);
IkReal x368=((0.04)*x362);
IkReal x369=((0.04)*x361);
IkReal x370=((0.6)*r21*x353);
IkReal x371=((0.76)*r00*x352);
IkReal x372=(x350+x357+x363+x364+x365);
IkReal x373=(x351+x358+x368+x366+x367);
IkReal x374=((((1.8)*r21*x353))+(((2.28)*r00*x352))+(((0.12)*x354))+(((1.8)*x356))+(((0.12)*x361)));
IkReal x375=(x359+x371+x370+x369+x360);
j1evalpoly[0]=((-0.68)+(((-0.24)*htj1))+(((htj1*htj1)*(((-0.68)+(((-1.0)*x374))+x372))))+(((htj1*htj1*htj1*htj1)*(((0.68)+(((-1.0)*x374))+x372))))+(((-1.0)*x375))+(((-0.24)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.48)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.68)+(((-1.0)*x375))+x373))))+x373);
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x376=((1.0)*cj1);
IkReal x377=(cj4*r22);
IkReal x378=(cj5*sj4);
IkReal x379=(sj4*sj5);
IkReal x380=((1.0)*sj1);
IkReal x381=(cj4*r02);
if( IKabs(((((-1.0)*x380*x381))+((r00*sj1*x378))+(((-1.0)*r01*x379*x380))+(((-1.0)*r21*x376*x379))+(((-1.0)*x376*x377))+((cj1*r20*x378)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r21*x379*x380))+((cj1*x381))+((r20*sj1*x378))+((cj1*r01*x379))+(((-1.0)*x377*x380))+(((-1.0)*r00*x376*x378)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x380*x381))+((r00*sj1*x378))+(((-1.0)*r01*x379*x380))+(((-1.0)*r21*x376*x379))+(((-1.0)*x376*x377))+((cj1*r20*x378))))+IKsqr(((((-1.0)*r21*x379*x380))+((cj1*x381))+((r20*sj1*x378))+((cj1*r01*x379))+(((-1.0)*x377*x380))+(((-1.0)*r00*x376*x378))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x380*x381))+((r00*sj1*x378))+(((-1.0)*r01*x379*x380))+(((-1.0)*r21*x376*x379))+(((-1.0)*x376*x377))+((cj1*r20*x378))), ((((-1.0)*r21*x379*x380))+((cj1*x381))+((r20*sj1*x378))+((cj1*r01*x379))+(((-1.0)*x377*x380))+(((-1.0)*r00*x376*x378))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x382=IKcos(j2);
IkReal x383=IKsin(j2);
IkReal x384=((0.15)*sj1);
IkReal x385=((1.0)*cj3);
IkReal x386=(r02*sj4);
IkReal x387=(cj5*r00);
IkReal x388=(r01*sj5);
IkReal x389=((1.0)*sj4);
IkReal x390=(cj5*sj3);
IkReal x391=((1.0)*sj1);
IkReal x392=(sj3*sj5);
IkReal x393=((1.0)*cj4);
IkReal x394=((0.01)*cj4);
IkReal x395=((0.19)*sj1);
IkReal x396=(r21*sj5);
IkReal x397=(r22*sj4);
IkReal x398=(cj1*x382);
IkReal x399=(cj3*cj4*sj5);
IkReal x400=(cj1*x383);
IkReal x401=(cj4*cj5*r20);
IkReal x402=(x382*x391);
IkReal x403=((1.0)*x400);
IkReal x404=(x403+x402);
evalcond[0]=((((-1.0)*r02*x393))+x398+((sj4*x387))+(((-1.0)*x383*x391))+(((-1.0)*x388*x389)));
evalcond[1]=(((cj5*r20*sj4))+(((-1.0)*x389*x396))+(((-1.0)*r22*x393))+(((-1.0)*x404)));
evalcond[2]=(((r20*x392))+(((-1.0)*x398))+((cj3*cj4*x396))+(((-1.0)*x385*x397))+((sj1*x383))+((r21*x390))+(((-1.0)*x385*x401)));
evalcond[3]=((((-1.0)*cj4*x385*x387))+((r00*x392))+((r01*x390))+((cj3*cj4*x388))+(((-1.0)*x385*x386))+(((-1.0)*x404)));
evalcond[4]=((((0.17)*cj1))+(((0.03)*sj1))+(((-1.0)*x394*x396))+(((0.01)*x397))+(((-0.19)*x398))+(((-1.0)*pz))+((cj5*r20*x394))+((x383*x395))+(((-0.15)*x400))+(((-1.0)*x382*x384)));
evalcond[5]=((0.03)+(((0.15)*x398))+(((0.17)*sj1))+(((-1.0)*x382*x395))+(((-1.0)*x388*x394))+(((-1.0)*px))+(((-0.19)*x400))+(((0.01)*x386))+((x387*x394))+(((-0.03)*cj1))+(((-1.0)*x383*x384)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x405=((1.0)*r01);
CheckValue<IkReal> x406=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)))),-1);
if(!x406.valid){
continue;
}
CheckValue<IkReal> x407 = IKatan2WithCheck(IkReal(((((-1.0)*r00*sj5))+(((-1.0)*cj5*x405)))),IkReal((((r02*sj4))+(((-1.0)*cj4*sj5*x405))+((cj4*cj5*r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x407.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x406.value)))+(x407.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x408=IKsin(j3);
IkReal x409=IKcos(j3);
IkReal x410=(r10*sj5);
IkReal x411=(cj4*sj5);
IkReal x412=(cj5*r11);
IkReal x413=(cj4*cj5);
IkReal x414=(r12*sj4);
IkReal x415=((1.0)*x409);
IkReal x416=((1.0)*x408);
evalcond[0]=(((x408*x410))+((x408*x412))+(((-1.0)*x414*x415))+(((-1.0)*r10*x413*x415))+((r11*x409*x411)));
evalcond[1]=(((r21*x408*x411))+(((-1.0)*cj5*r21*x415))+(((-1.0)*r22*sj4*x416))+(((-1.0)*r20*x413*x416))+(((-1.0)*r20*sj5*x415)));
evalcond[2]=(((r01*x408*x411))+(((-1.0)*r00*x413*x416))+(((-1.0)*cj5*r01*x415))+(((-1.0)*r02*sj4*x416))+(((-1.0)*r00*sj5*x415)));
evalcond[3]=((1.0)+(((-1.0)*x412*x415))+(((-1.0)*x410*x415))+(((-1.0)*x414*x416))+((r11*x408*x411))+(((-1.0)*r10*x413*x416)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x417=((12.0)*px);
IkReal x418=((12.0)*pz);
IkReal x419=(r01*sj5);
IkReal x420=((0.12)*cj4);
IkReal x421=((0.76)*sj4);
IkReal x422=((0.12)*sj4);
IkReal x423=(cj4*r02);
IkReal x424=((0.04)*sj4);
IkReal x425=(cj4*r22);
IkReal x426=(cj5*r20);
IkReal x427=((0.04)*cj4);
IkReal x428=(cj5*r00);
IkReal x429=(r21*sj5);
IkReal x430=((1.8)*sj4);
IkReal x431=((0.6)*sj4);
IkReal x432=((2.28)*sj4);
IkReal x433=((2.28)*x423);
IkReal x434=(sj4*x428);
IkReal x435=(sj4*x426);
IkReal x436=(x419*x420);
IkReal x437=(x428*x430);
IkReal x438=(x426*x432);
IkReal x439=(x419*x432);
IkReal x440=(x426*x430);
IkReal x441=(x420*x429);
IkReal x442=(x417+x438+x436+x437);
IkReal x443=(x418+x439+x433+x441+x440);
IkReal x444=(((x429*x430))+((x420*x426))+((x428*x432))+(((1.8)*x425))+((r22*x422)));
IkReal x445=(((x429*x432))+((x420*x428))+(((1.8)*x423))+((r02*x422))+((x419*x430))+(((2.28)*x425)));
j1eval[0]=((6.4)+(IKabs(((-0.24)+(((-1.0)*x445))+x442)))+(IKabs(((-0.68)+(((-1.0)*x444))+x443)))+(IKabs(((-0.48)+(((-1.0)*x445))+x442)))+(IKabs(((-0.24)+(((-1.0)*x421*x429))+((x428*x431))+(((4.0)*px))+(((-1.0)*x427*x428))+((x419*x427))+(((-1.0)*r02*x424))+(((-0.6)*x423))+(((-1.0)*x419*x431))+(((-0.76)*x425))+((x421*x426)))))+(IKabs(((0.68)+(((-1.0)*x444))+x443)))+(IKabs(((0.68)+(((-1.0)*x421*x428))+((x427*x429))+((x426*x431))+(((4.0)*pz))+(((-1.0)*x429*x431))+((x419*x421))+(((-1.0)*x426*x427))+(((0.76)*x423))+(((-0.6)*x425))+(((-1.0)*r22*x424))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x446=((12.0)*px);
IkReal x447=((4.0)*px);
IkReal x448=(r02*sj4);
IkReal x449=(cj4*r02);
IkReal x450=(cj4*r22);
IkReal x451=(cj5*sj4);
IkReal x452=(cj4*r01*sj5);
IkReal x453=(cj4*cj5*r00);
IkReal x454=(r01*sj4*sj5);
IkReal x455=(r21*sj4*sj5);
IkReal x456=((0.12)*x452);
IkReal x457=((1.8)*r00*x451);
IkReal x458=((2.28)*r20*x451);
IkReal x459=((0.76)*r20*x451);
IkReal x460=((0.6)*r00*x451);
IkReal x461=((0.04)*x452);
IkReal x462=(x446+x458+x456+x457);
IkReal x463=(x447+x459+x461+x460);
IkReal x464=((((2.28)*x455))+(((2.28)*x450))+(((0.12)*x453))+(((0.12)*x448))+(((1.8)*x449))+(((1.8)*x454)));
IkReal x465=((((0.76)*x455))+(((0.76)*x450))+(((0.6)*x454))+(((0.04)*x453))+(((0.04)*x448))+(((0.6)*x449)));
op[0]=((-0.24)+(((-1.0)*x465))+x463);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x464))+x462);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x464))+x462);
op[5]=-1.36;
op[6]=((((-1.0)*x465))+x463);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x466=((12.0)*pz);
IkReal x467=((4.0)*pz);
IkReal x468=(cj5*sj4);
IkReal x469=(sj4*sj5);
IkReal x470=(r22*sj4);
IkReal x471=(cj4*r02);
IkReal x472=(cj4*r22);
IkReal x473=((2.28)*x471);
IkReal x474=((0.76)*x471);
IkReal x475=((0.6)*x472);
IkReal x476=((0.04)*x470);
IkReal x477=(cj4*cj5*r20);
IkReal x478=(cj4*r21*sj5);
IkReal x479=((2.28)*r01*x469);
IkReal x480=((1.8)*r20*x468);
IkReal x481=((0.12)*x478);
IkReal x482=((0.6)*r20*x468);
IkReal x483=((0.76)*r01*x469);
IkReal x484=((0.04)*x478);
IkReal x485=((0.04)*x477);
IkReal x486=((0.6)*r21*x469);
IkReal x487=((0.76)*r00*x468);
IkReal x488=(x481+x480+x466+x473+x479);
IkReal x489=(x483+x482+x484+x467+x474);
IkReal x490=((((0.12)*x470))+(((0.12)*x477))+(((1.8)*r21*x469))+(((2.28)*r00*x468))+(((1.8)*x472)));
IkReal x491=(x485+x487+x486+x475+x476);
j1evalpoly[0]=((-0.68)+(((-0.24)*htj1))+(((-1.0)*x491))+(((htj1*htj1*htj1*htj1)*(((0.68)+(((-1.0)*x490))+x488))))+(((-0.24)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.48)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.68)+(((-1.0)*x491))+x489))))+x489+(((htj1*htj1)*(((-0.68)+(((-1.0)*x490))+x488)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x492=((1.0)*cj1);
IkReal x493=(cj4*r22);
IkReal x494=(cj5*sj4);
IkReal x495=(sj4*sj5);
IkReal x496=((1.0)*sj1);
IkReal x497=(cj4*r02);
if( IKabs(((((-1.0)*x496*x497))+(((-1.0)*r01*x495*x496))+((cj1*r20*x494))+((r00*sj1*x494))+(((-1.0)*r21*x492*x495))+(((-1.0)*x492*x493)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r01*x495))+(((-1.0)*r21*x495*x496))+((r20*sj1*x494))+(((-1.0)*x493*x496))+((cj1*x497))+(((-1.0)*r00*x492*x494)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x496*x497))+(((-1.0)*r01*x495*x496))+((cj1*r20*x494))+((r00*sj1*x494))+(((-1.0)*r21*x492*x495))+(((-1.0)*x492*x493))))+IKsqr((((cj1*r01*x495))+(((-1.0)*r21*x495*x496))+((r20*sj1*x494))+(((-1.0)*x493*x496))+((cj1*x497))+(((-1.0)*r00*x492*x494))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x496*x497))+(((-1.0)*r01*x495*x496))+((cj1*r20*x494))+((r00*sj1*x494))+(((-1.0)*r21*x492*x495))+(((-1.0)*x492*x493))), (((cj1*r01*x495))+(((-1.0)*r21*x495*x496))+((r20*sj1*x494))+(((-1.0)*x493*x496))+((cj1*x497))+(((-1.0)*r00*x492*x494))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x498=IKcos(j2);
IkReal x499=IKsin(j2);
IkReal x500=((0.15)*sj1);
IkReal x501=((1.0)*cj3);
IkReal x502=(r02*sj4);
IkReal x503=(cj5*r00);
IkReal x504=(r01*sj5);
IkReal x505=((1.0)*sj4);
IkReal x506=(cj5*sj3);
IkReal x507=((1.0)*sj1);
IkReal x508=(sj3*sj5);
IkReal x509=((1.0)*cj4);
IkReal x510=((0.01)*cj4);
IkReal x511=((0.19)*sj1);
IkReal x512=(r21*sj5);
IkReal x513=(r22*sj4);
IkReal x514=(cj1*x498);
IkReal x515=(cj3*cj4*sj5);
IkReal x516=(cj1*x499);
IkReal x517=(cj4*cj5*r20);
IkReal x518=(x498*x507);
IkReal x519=((1.0)*x516);
IkReal x520=(x519+x518);
evalcond[0]=((((-1.0)*x499*x507))+x514+(((-1.0)*x504*x505))+((sj4*x503))+(((-1.0)*r02*x509)));
evalcond[1]=(((cj5*r20*sj4))+(((-1.0)*r22*x509))+(((-1.0)*x520))+(((-1.0)*x505*x512)));
evalcond[2]=(((r20*x508))+(((-1.0)*x501*x517))+(((-1.0)*x501*x513))+((r21*x506))+(((-1.0)*x514))+((cj3*cj4*x512))+((sj1*x499)));
evalcond[3]=((((-1.0)*x501*x502))+(((-1.0)*x520))+((r01*x506))+((r00*x508))+(((-1.0)*cj4*x501*x503))+((cj3*cj4*x504)));
evalcond[4]=((((0.17)*cj1))+(((0.03)*sj1))+(((-0.19)*x514))+(((-0.15)*x516))+((x499*x511))+(((-1.0)*pz))+((cj5*r20*x510))+(((0.01)*x513))+(((-1.0)*x498*x500))+(((-1.0)*x510*x512)));
evalcond[5]=((0.03)+(((-1.0)*x499*x500))+(((-0.19)*x516))+(((-1.0)*x504*x510))+(((0.01)*x502))+((x503*x510))+(((0.17)*sj1))+(((-1.0)*px))+(((-1.0)*x498*x511))+(((-0.03)*cj1))+(((0.15)*x514)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x521=((1.0)*sj5);
IkReal x522=((1.0)*cj5);
IkReal x523=(((r01*sj4*sj5))+(((-1.0)*r00*sj4*x522))+((cj4*r02)));
j3eval[0]=x523;
j3eval[1]=IKsign(x523);
j3eval[2]=((IKabs((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*r21*x521)))))+(IKabs(((((-1.0)*r21*x522))+(((-1.0)*r20*x521))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x524=((1.0)*r01);
IkReal x525=((1.0)*sj5);
IkReal x526=(((cj5*r20*sj4))+(((-1.0)*r21*sj4*x525))+(((-1.0)*cj4*r22)));
j3eval[0]=x526;
j3eval[1]=((IKabs(((((-1.0)*r00*x525))+(((-1.0)*cj5*x524)))))+(IKabs((((r02*sj4))+(((-1.0)*cj4*sj5*x524))+((cj4*cj5*r00))))));
j3eval[2]=IKsign(x526);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x527=cj4*cj4;
IkReal x528=r10*r10;
IkReal x529=cj5*cj5;
IkReal x530=r11*r11;
IkReal x531=r12*r12;
IkReal x532=(r11*sj5);
IkReal x533=((1.0)*r10);
IkReal x534=(r12*sj4);
IkReal x535=((1.0)*x527);
IkReal x536=((2.0)*cj5*r10);
IkReal x537=(x529*x530);
IkReal x538=(x528*x529);
IkReal x539=((((-1.0)*x538))+(((-1.0)*x531*x535))+x531+x537+x528+((cj4*x534*x536))+(((-1.0)*x535*x537))+(((-1.0)*x527*x532*x536))+((x527*x538))+((x527*x530))+((x532*x536))+(((-2.0)*cj4*x532*x534)));
j3eval[0]=x539;
j3eval[1]=IKsign(x539);
j3eval[2]=((IKabs(((((-1.0)*cj5*r11))+(((-1.0)*sj5*x533)))))+(IKabs((((cj4*x532))+(((-1.0)*x534))+(((-1.0)*cj4*cj5*x533))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x540=cj4*cj4;
IkReal x541=r10*r10;
IkReal x542=cj5*cj5;
IkReal x543=r11*r11;
IkReal x544=r12*r12;
IkReal x545=(r11*sj5);
IkReal x546=((1.0)*cj5);
IkReal x547=(r12*sj4);
IkReal x548=((1.0)*x540);
IkReal x549=((2.0)*cj5*r10);
IkReal x550=(x542*x543);
IkReal x551=(x541*x542);
CheckValue<IkReal> x552=IKPowWithIntegerCheck(IKsign(((((-2.0)*cj4*x545*x547))+(((-1.0)*x544*x548))+(((-1.0)*x551))+((x540*x543))+((x540*x551))+(((-1.0)*x548*x550))+x550+x544+x541+(((-1.0)*x540*x545*x549))+((cj4*x547*x549))+((x545*x549)))),-1);
if(!x552.valid){
continue;
}
CheckValue<IkReal> x553 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*r10*x546))+((cj4*x545))+(((-1.0)*x547)))),IkReal(((((-1.0)*r10*sj5))+(((-1.0)*r11*x546)))),IKFAST_ATAN2_MAGTHRESH);
if(!x553.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x552.value)))+(x553.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x554=IKsin(j3);
IkReal x555=IKcos(j3);
IkReal x556=(r10*sj5);
IkReal x557=(cj4*sj5);
IkReal x558=(cj5*r11);
IkReal x559=(cj4*cj5);
IkReal x560=(r12*sj4);
IkReal x561=((1.0)*x555);
IkReal x562=((1.0)*x554);
evalcond[0]=(((x554*x558))+((x554*x556))+(((-1.0)*r10*x559*x561))+(((-1.0)*x560*x561))+((r11*x555*x557)));
evalcond[1]=((((-1.0)*cj5*r21*x561))+(((-1.0)*r20*x559*x562))+((r21*x554*x557))+(((-1.0)*r22*sj4*x562))+(((-1.0)*r20*sj5*x561)));
evalcond[2]=(((r01*x554*x557))+(((-1.0)*r00*x559*x562))+(((-1.0)*cj5*r01*x561))+(((-1.0)*r00*sj5*x561))+(((-1.0)*r02*sj4*x562)));
evalcond[3]=((-1.0)+((r11*x554*x557))+(((-1.0)*x558*x561))+(((-1.0)*x556*x561))+(((-1.0)*r10*x559*x562))+(((-1.0)*x560*x562)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x563=(r01*sj5);
IkReal x564=((0.12)*cj4);
IkReal x565=((0.76)*sj4);
IkReal x566=((0.12)*sj4);
IkReal x567=(cj4*r02);
IkReal x568=((0.04)*sj4);
IkReal x569=(cj4*r22);
IkReal x570=(cj5*r20);
IkReal x571=((0.04)*cj4);
IkReal x572=(cj5*r00);
IkReal x573=(r21*sj5);
IkReal x574=((1.8)*sj4);
IkReal x575=((0.6)*sj4);
IkReal x576=((2.28)*sj4);
IkReal x577=(r02*x566);
IkReal x578=((1.8)*x567);
IkReal x579=(r22*x566);
IkReal x580=((1.8)*x569);
IkReal x581=((2.28)*x567);
IkReal x582=(sj4*x572);
IkReal x583=(sj4*x570);
IkReal x584=(x564*x572);
IkReal x585=(x570*x576);
IkReal x586=(x563*x574);
IkReal x587=(x563*x576);
IkReal x588=(x573*x574);
IkReal x589=(x564*x570);
IkReal x590=((((12.0)*pz))+((x564*x573))+((x572*x576))+((x570*x574)));
IkReal x591=((((2.28)*x569))+(((12.0)*px))+((x563*x564))+((x573*x576))+((x572*x574)));
IkReal x592=(x578+x577+x584+x585+x586);
IkReal x593=(x579+x580+x581+x587+x588+x589);
j1eval[0]=((6.4)+(IKabs(((-0.24)+(((0.6)*x567))+((x571*x572))+((x563*x575))+(((-1.0)*x565*x573))+(((-0.76)*x569))+(((-1.0)*x563*x571))+((x565*x570))+((r02*x568))+(((-4.0)*px))+(((-1.0)*x572*x575)))))+(IKabs(((-0.68)+(((0.6)*x569))+(((0.76)*x567))+((r22*x568))+(((-1.0)*x570*x575))+(((-1.0)*x571*x573))+((x563*x565))+((x573*x575))+(((-1.0)*x565*x572))+(((-4.0)*pz))+((x570*x571)))))+(IKabs(((-0.24)+(((-1.0)*x591))+x592)))+(IKabs(((0.68)+(((-1.0)*x590))+x593)))+(IKabs(((-0.68)+(((-1.0)*x590))+x593)))+(IKabs(((-0.48)+(((-1.0)*x591))+x592))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x594=(r02*sj4);
IkReal x595=(cj4*r02);
IkReal x596=(cj4*r22);
IkReal x597=(cj5*sj4);
IkReal x598=(sj4*sj5);
IkReal x599=((0.12)*x594);
IkReal x600=((1.8)*x595);
IkReal x601=((0.04)*x594);
IkReal x602=((0.6)*x595);
IkReal x603=(cj4*r01*sj5);
IkReal x604=(cj4*cj5*r00);
IkReal x605=((0.12)*x604);
IkReal x606=((2.28)*r20*x597);
IkReal x607=((1.8)*r01*x598);
IkReal x608=((0.76)*r20*x597);
IkReal x609=((0.04)*x604);
IkReal x610=((0.6)*r01*x598);
IkReal x611=((((2.28)*x596))+(((12.0)*px))+(((2.28)*r21*x598))+(((0.12)*x603))+(((1.8)*r00*x597)));
IkReal x612=((((0.6)*r00*x597))+(((4.0)*px))+(((0.76)*x596))+(((0.04)*x603))+(((0.76)*r21*x598)));
IkReal x613=(x599+x600+x607+x606+x605);
IkReal x614=(x602+x601+x609+x608+x610);
op[0]=((-0.24)+(((-1.0)*x612))+x614);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x611))+x613);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x611))+x613);
op[5]=-1.36;
op[6]=((((-1.0)*x612))+x614);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x615=(cj5*sj4);
IkReal x616=(sj4*sj5);
IkReal x617=(cj4*r02);
IkReal x618=(r22*sj4);
IkReal x619=(cj4*r22);
IkReal x620=((0.12)*x618);
IkReal x621=((1.8)*x619);
IkReal x622=((2.28)*x617);
IkReal x623=((0.6)*x619);
IkReal x624=((0.76)*x617);
IkReal x625=((0.04)*x618);
IkReal x626=(cj4*cj5*r20);
IkReal x627=(cj4*r21*sj5);
IkReal x628=((2.28)*r01*x616);
IkReal x629=((1.8)*r21*x616);
IkReal x630=((0.12)*x626);
IkReal x631=((0.04)*x626);
IkReal x632=((0.6)*r21*x616);
IkReal x633=((0.76)*r01*x616);
IkReal x634=((((0.12)*x627))+(((12.0)*pz))+(((1.8)*r20*x615))+(((2.28)*r00*x615)));
IkReal x635=((((0.6)*r20*x615))+(((0.76)*r00*x615))+(((4.0)*pz))+(((0.04)*x627)));
IkReal x636=(x621+x620+x622+x629+x628+x630);
IkReal x637=(x625+x624+x623+x632+x633+x631);
j1evalpoly[0]=((0.68)+(((0.48)*(htj1*htj1*htj1)))+(((-1.0)*x635))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.68)+(((-1.0)*x635))+x637))))+(((htj1*htj1*htj1*htj1)*(((-0.68)+(((-1.0)*x634))+x636))))+x637+(((htj1*htj1)*(((0.68)+(((-1.0)*x634))+x636))))+(((0.24)*htj1))+(((0.24)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x638=(sj1*sj4);
IkReal x639=(r01*sj5);
IkReal x640=((1.0)*cj1);
IkReal x641=(cj4*r22);
IkReal x642=(cj4*r02);
IkReal x643=(cj5*r20);
IkReal x644=(cj1*sj4);
IkReal x645=(cj5*r00);
IkReal x646=(r21*sj5);
if( IKabs((((x643*x644))+((sj1*x642))+(((-1.0)*x640*x641))+((x638*x639))+(((-1.0)*sj4*x640*x646))+(((-1.0)*x638*x645)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x638*x643))+((x644*x645))+(((-1.0)*x640*x642))+(((-1.0)*sj4*x639*x640))+(((-1.0)*x638*x646))+(((-1.0)*sj1*x641)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x643*x644))+((sj1*x642))+(((-1.0)*x640*x641))+((x638*x639))+(((-1.0)*sj4*x640*x646))+(((-1.0)*x638*x645))))+IKsqr((((x638*x643))+((x644*x645))+(((-1.0)*x640*x642))+(((-1.0)*sj4*x639*x640))+(((-1.0)*x638*x646))+(((-1.0)*sj1*x641))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x643*x644))+((sj1*x642))+(((-1.0)*x640*x641))+((x638*x639))+(((-1.0)*sj4*x640*x646))+(((-1.0)*x638*x645))), (((x638*x643))+((x644*x645))+(((-1.0)*x640*x642))+(((-1.0)*sj4*x639*x640))+(((-1.0)*x638*x646))+(((-1.0)*sj1*x641))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x647=IKcos(j2);
IkReal x648=IKsin(j2);
IkReal x649=((0.15)*sj1);
IkReal x650=((1.0)*cj3);
IkReal x651=(r02*sj4);
IkReal x652=(cj5*r00);
IkReal x653=(r01*sj5);
IkReal x654=((1.0)*sj4);
IkReal x655=(cj5*sj3);
IkReal x656=(sj3*sj5);
IkReal x657=((1.0)*cj4);
IkReal x658=((0.01)*cj4);
IkReal x659=(r21*sj5);
IkReal x660=(r22*sj4);
IkReal x661=(sj1*x648);
IkReal x662=(cj3*cj4*sj5);
IkReal x663=(cj1*x647);
IkReal x664=(cj1*x648);
IkReal x665=(cj4*cj5*r20);
IkReal x666=(sj1*x647);
IkReal x667=((1.0)*x663);
evalcond[0]=(((sj4*x652))+(((-1.0)*x667))+(((-1.0)*r02*x657))+x661+(((-1.0)*x653*x654)));
evalcond[1]=(((cj5*r20*sj4))+(((-1.0)*r22*x657))+(((-1.0)*x664))+(((-1.0)*x666))+(((-1.0)*x654*x659)));
evalcond[2]=(((cj3*cj4*x653))+x664+x666+(((-1.0)*x650*x651))+((r00*x656))+((r01*x655))+(((-1.0)*cj4*x650*x652)));
evalcond[3]=(((cj3*cj4*x659))+(((-1.0)*x667))+x661+(((-1.0)*x650*x660))+(((-1.0)*x650*x665))+((r21*x655))+((r20*x656)));
evalcond[4]=((((0.17)*cj1))+(((0.03)*sj1))+(((-0.15)*x664))+(((-1.0)*x647*x649))+(((-1.0)*pz))+(((0.19)*x661))+(((-0.19)*x663))+(((-1.0)*x658*x659))+(((0.01)*x660))+((cj5*r20*x658)));
evalcond[5]=((-0.03)+((x648*x649))+(((-0.15)*x663))+((x652*x658))+(((0.03)*cj1))+(((-1.0)*px))+(((0.01)*x651))+(((0.19)*x666))+(((0.19)*x664))+(((-0.17)*sj1))+(((-1.0)*x653*x658)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x668=((1.0)*r01);
IkReal x669=((1.0)*sj5);
CheckValue<IkReal> x670 = IKatan2WithCheck(IkReal(((((-1.0)*r00*x669))+(((-1.0)*cj5*x668)))),IkReal((((r02*sj4))+((cj4*cj5*r00))+(((-1.0)*cj4*sj5*x668)))),IKFAST_ATAN2_MAGTHRESH);
if(!x670.valid){
continue;
}
CheckValue<IkReal> x671=IKPowWithIntegerCheck(IKsign((((cj5*r20*sj4))+(((-1.0)*r21*sj4*x669))+(((-1.0)*cj4*r22)))),-1);
if(!x671.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x670.value)+(((1.5707963267949)*(x671.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x672=IKsin(j3);
IkReal x673=IKcos(j3);
IkReal x674=(r10*sj5);
IkReal x675=(cj4*sj5);
IkReal x676=(cj5*r11);
IkReal x677=(cj4*cj5);
IkReal x678=(r12*sj4);
IkReal x679=((1.0)*x673);
IkReal x680=((1.0)*x672);
evalcond[0]=((((-1.0)*r10*x677*x679))+((x672*x676))+((x672*x674))+(((-1.0)*x678*x679))+((r11*x673*x675)));
evalcond[1]=((((-1.0)*r20*x677*x680))+(((-1.0)*r20*sj5*x679))+(((-1.0)*cj5*r21*x679))+((r21*x672*x675))+(((-1.0)*r22*sj4*x680)));
evalcond[2]=(((r01*x672*x675))+(((-1.0)*r00*sj5*x679))+(((-1.0)*r02*sj4*x680))+(((-1.0)*r00*x677*x680))+(((-1.0)*cj5*r01*x679)));
evalcond[3]=((-1.0)+(((-1.0)*r10*x677*x680))+((r11*x672*x675))+(((-1.0)*x678*x680))+(((-1.0)*x676*x679))+(((-1.0)*x674*x679)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x681=(r01*sj5);
IkReal x682=((0.12)*cj4);
IkReal x683=((0.76)*sj4);
IkReal x684=((0.12)*sj4);
IkReal x685=(cj4*r02);
IkReal x686=((0.04)*sj4);
IkReal x687=(cj4*r22);
IkReal x688=(cj5*r20);
IkReal x689=((0.04)*cj4);
IkReal x690=(cj5*r00);
IkReal x691=(r21*sj5);
IkReal x692=((1.8)*sj4);
IkReal x693=((0.6)*sj4);
IkReal x694=((2.28)*sj4);
IkReal x695=(r02*x684);
IkReal x696=((1.8)*x685);
IkReal x697=(r22*x684);
IkReal x698=((1.8)*x687);
IkReal x699=((2.28)*x685);
IkReal x700=(sj4*x690);
IkReal x701=(sj4*x688);
IkReal x702=(x682*x690);
IkReal x703=(x688*x694);
IkReal x704=(x681*x692);
IkReal x705=(x681*x694);
IkReal x706=(x691*x692);
IkReal x707=(x682*x688);
IkReal x708=(((x682*x691))+((x688*x692))+(((12.0)*pz))+((x690*x694)));
IkReal x709=((((12.0)*px))+(((2.28)*x687))+((x690*x692))+((x691*x694))+((x681*x682)));
IkReal x710=(x695+x696+x702+x703+x704);
IkReal x711=(x697+x698+x699+x706+x707+x705);
j1eval[0]=((6.4)+(IKabs(((-0.68)+(((-1.0)*x708))+x711)))+(IKabs(((-0.68)+((r22*x686))+((x688*x689))+((x691*x693))+(((-1.0)*x683*x690))+(((0.6)*x687))+(((-1.0)*x688*x693))+((x681*x683))+(((-1.0)*x689*x691))+(((-4.0)*pz))+(((0.76)*x685)))))+(IKabs(((-0.24)+(((-1.0)*x681*x689))+((x683*x688))+(((-0.76)*x687))+((x689*x690))+(((-1.0)*x683*x691))+(((0.6)*x685))+((x681*x693))+(((-1.0)*x690*x693))+(((-4.0)*px))+((r02*x686)))))+(IKabs(((0.68)+(((-1.0)*x708))+x711)))+(IKabs(((-0.48)+(((-1.0)*x709))+x710)))+(IKabs(((-0.24)+(((-1.0)*x709))+x710))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x712=(r02*sj4);
IkReal x713=(cj4*r02);
IkReal x714=(cj4*r22);
IkReal x715=(cj5*sj4);
IkReal x716=(sj4*sj5);
IkReal x717=((0.12)*x712);
IkReal x718=((1.8)*x713);
IkReal x719=((0.04)*x712);
IkReal x720=((0.6)*x713);
IkReal x721=(cj4*r01*sj5);
IkReal x722=(cj4*cj5*r00);
IkReal x723=((0.12)*x722);
IkReal x724=((2.28)*r20*x715);
IkReal x725=((1.8)*r01*x716);
IkReal x726=((0.76)*r20*x715);
IkReal x727=((0.04)*x722);
IkReal x728=((0.6)*r01*x716);
IkReal x729=((((1.8)*r00*x715))+(((12.0)*px))+(((2.28)*r21*x716))+(((0.12)*x721))+(((2.28)*x714)));
IkReal x730=((((0.76)*r21*x716))+(((0.04)*x721))+(((4.0)*px))+(((0.76)*x714))+(((0.6)*r00*x715)));
IkReal x731=(x718+x717+x723+x724+x725);
IkReal x732=(x719+x720+x726+x727+x728);
op[0]=((-0.24)+(((-1.0)*x730))+x732);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x729))+x731);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x729))+x731);
op[5]=-1.36;
op[6]=((((-1.0)*x730))+x732);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x733=(cj5*sj4);
IkReal x734=(sj4*sj5);
IkReal x735=(cj4*r02);
IkReal x736=(r22*sj4);
IkReal x737=(cj4*r22);
IkReal x738=((0.12)*x736);
IkReal x739=((1.8)*x737);
IkReal x740=((2.28)*x735);
IkReal x741=((0.6)*x737);
IkReal x742=((0.76)*x735);
IkReal x743=((0.04)*x736);
IkReal x744=(cj4*cj5*r20);
IkReal x745=(cj4*r21*sj5);
IkReal x746=((2.28)*r01*x734);
IkReal x747=((1.8)*r21*x734);
IkReal x748=((0.12)*x744);
IkReal x749=((0.04)*x744);
IkReal x750=((0.6)*r21*x734);
IkReal x751=((0.76)*r01*x734);
IkReal x752=((((1.8)*r20*x733))+(((2.28)*r00*x733))+(((12.0)*pz))+(((0.12)*x745)));
IkReal x753=((((0.76)*r00*x733))+(((0.6)*r20*x733))+(((4.0)*pz))+(((0.04)*x745)));
IkReal x754=(x739+x738+x746+x747+x740+x748);
IkReal x755=(x751+x750+x742+x743+x741+x749);
j1evalpoly[0]=((0.68)+(((htj1*htj1*htj1*htj1)*(((-0.68)+x754+(((-1.0)*x752))))))+(((0.48)*(htj1*htj1*htj1)))+(((htj1*htj1)*(((0.68)+x754+(((-1.0)*x752))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.68)+x755+(((-1.0)*x753))))))+x755+(((0.24)*htj1))+(((-1.0)*x753))+(((0.24)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x756=(sj1*sj4);
IkReal x757=(r01*sj5);
IkReal x758=((1.0)*cj1);
IkReal x759=(cj4*r22);
IkReal x760=(cj4*r02);
IkReal x761=(cj5*r20);
IkReal x762=(cj1*sj4);
IkReal x763=(cj5*r00);
IkReal x764=(r21*sj5);
if( IKabs((((x756*x757))+(((-1.0)*x756*x763))+((sj1*x760))+(((-1.0)*sj4*x758*x764))+((x761*x762))+(((-1.0)*x758*x759)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x758*x760))+(((-1.0)*x756*x764))+(((-1.0)*sj1*x759))+((x762*x763))+((x756*x761))+(((-1.0)*sj4*x757*x758)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x756*x757))+(((-1.0)*x756*x763))+((sj1*x760))+(((-1.0)*sj4*x758*x764))+((x761*x762))+(((-1.0)*x758*x759))))+IKsqr(((((-1.0)*x758*x760))+(((-1.0)*x756*x764))+(((-1.0)*sj1*x759))+((x762*x763))+((x756*x761))+(((-1.0)*sj4*x757*x758))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x756*x757))+(((-1.0)*x756*x763))+((sj1*x760))+(((-1.0)*sj4*x758*x764))+((x761*x762))+(((-1.0)*x758*x759))), ((((-1.0)*x758*x760))+(((-1.0)*x756*x764))+(((-1.0)*sj1*x759))+((x762*x763))+((x756*x761))+(((-1.0)*sj4*x757*x758))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x765=IKcos(j2);
IkReal x766=IKsin(j2);
IkReal x767=((0.15)*sj1);
IkReal x768=((1.0)*cj3);
IkReal x769=(r02*sj4);
IkReal x770=(cj5*r00);
IkReal x771=(r01*sj5);
IkReal x772=((1.0)*sj4);
IkReal x773=(cj5*sj3);
IkReal x774=(sj3*sj5);
IkReal x775=((1.0)*cj4);
IkReal x776=((0.01)*cj4);
IkReal x777=(r21*sj5);
IkReal x778=(r22*sj4);
IkReal x779=(sj1*x766);
IkReal x780=(cj3*cj4*sj5);
IkReal x781=(cj1*x765);
IkReal x782=(cj1*x766);
IkReal x783=(cj4*cj5*r20);
IkReal x784=(sj1*x765);
IkReal x785=((1.0)*x781);
evalcond[0]=(((sj4*x770))+(((-1.0)*x785))+(((-1.0)*r02*x775))+(((-1.0)*x771*x772))+x779);
evalcond[1]=(((cj5*r20*sj4))+(((-1.0)*r22*x775))+(((-1.0)*x772*x777))+(((-1.0)*x784))+(((-1.0)*x782)));
evalcond[2]=((((-1.0)*cj4*x768*x770))+((r01*x773))+((r00*x774))+x782+x784+(((-1.0)*x768*x769))+((cj3*cj4*x771)));
evalcond[3]=((((-1.0)*x768*x778))+(((-1.0)*x785))+((r21*x773))+((r20*x774))+(((-1.0)*x768*x783))+x779+((cj3*cj4*x777)));
evalcond[4]=((((0.17)*cj1))+(((0.19)*x779))+(((0.03)*sj1))+(((-1.0)*x765*x767))+(((-0.19)*x781))+((cj5*r20*x776))+(((-0.15)*x782))+(((-1.0)*pz))+(((0.01)*x778))+(((-1.0)*x776*x777)));
evalcond[5]=((-0.03)+((x770*x776))+(((0.03)*cj1))+(((-0.15)*x781))+(((-1.0)*px))+(((-1.0)*x771*x776))+((x766*x767))+(((0.01)*x769))+(((-0.17)*sj1))+(((0.19)*x784))+(((0.19)*x782)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x786=((1.0)*cj5);
IkReal x787=((1.0)*sj5);
CheckValue<IkReal> x788 = IKatan2WithCheck(IkReal(((((-1.0)*r20*x787))+(((-1.0)*r21*x786)))),IkReal((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*r21*x787)))),IKFAST_ATAN2_MAGTHRESH);
if(!x788.valid){
continue;
}
CheckValue<IkReal> x789=IKPowWithIntegerCheck(IKsign((((r01*sj4*sj5))+(((-1.0)*r00*sj4*x786))+((cj4*r02)))),-1);
if(!x789.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x788.value)+(((1.5707963267949)*(x789.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x790=IKsin(j3);
IkReal x791=IKcos(j3);
IkReal x792=(r10*sj5);
IkReal x793=(cj4*sj5);
IkReal x794=(cj5*r11);
IkReal x795=(cj4*cj5);
IkReal x796=(r12*sj4);
IkReal x797=((1.0)*x791);
IkReal x798=((1.0)*x790);
evalcond[0]=((((-1.0)*x796*x797))+((x790*x794))+((x790*x792))+((r11*x791*x793))+(((-1.0)*r10*x795*x797)));
evalcond[1]=(((r21*x790*x793))+(((-1.0)*r20*sj5*x797))+(((-1.0)*r22*sj4*x798))+(((-1.0)*cj5*r21*x797))+(((-1.0)*r20*x795*x798)));
evalcond[2]=((((-1.0)*r02*sj4*x798))+(((-1.0)*cj5*r01*x797))+((r01*x790*x793))+(((-1.0)*r00*x795*x798))+(((-1.0)*r00*sj5*x797)));
evalcond[3]=((-1.0)+(((-1.0)*x794*x797))+(((-1.0)*x796*x798))+(((-1.0)*x792*x797))+((r11*x790*x793))+(((-1.0)*r10*x795*x798)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x799=(r01*sj5);
IkReal x800=((0.12)*cj4);
IkReal x801=((0.76)*sj4);
IkReal x802=((0.12)*sj4);
IkReal x803=(cj4*r02);
IkReal x804=((0.04)*sj4);
IkReal x805=(cj4*r22);
IkReal x806=(cj5*r20);
IkReal x807=((0.04)*cj4);
IkReal x808=(cj5*r00);
IkReal x809=(r21*sj5);
IkReal x810=((1.8)*sj4);
IkReal x811=((0.6)*sj4);
IkReal x812=((2.28)*sj4);
IkReal x813=(r02*x802);
IkReal x814=((1.8)*x803);
IkReal x815=(r22*x802);
IkReal x816=((1.8)*x805);
IkReal x817=((2.28)*x803);
IkReal x818=(sj4*x808);
IkReal x819=(sj4*x806);
IkReal x820=(x800*x808);
IkReal x821=(x806*x812);
IkReal x822=(x799*x810);
IkReal x823=(x799*x812);
IkReal x824=(x809*x810);
IkReal x825=(x800*x806);
IkReal x826=((((12.0)*pz))+((x800*x809))+((x808*x812))+((x806*x810)));
IkReal x827=(((x809*x812))+(((12.0)*px))+((x808*x810))+(((2.28)*x805))+((x799*x800)));
IkReal x828=(x814+x813+x822+x821+x820);
IkReal x829=(x816+x817+x815+x823+x825+x824);
j1eval[0]=((6.4)+(IKabs(((0.68)+(((-1.0)*x826))+x829)))+(IKabs(((-0.68)+(((-1.0)*x826))+x829)))+(IKabs(((-0.48)+(((-1.0)*x827))+x828)))+(IKabs(((-0.24)+(((-1.0)*x827))+x828)))+(IKabs(((-0.68)+(((0.76)*x803))+((x809*x811))+(((-1.0)*x807*x809))+((x806*x807))+((r22*x804))+((x799*x801))+(((-4.0)*pz))+(((-1.0)*x801*x808))+(((-1.0)*x806*x811))+(((0.6)*x805)))))+(IKabs(((-0.24)+((x799*x811))+(((-1.0)*x808*x811))+(((-1.0)*x799*x807))+(((-0.76)*x805))+((r02*x804))+((x801*x806))+(((-4.0)*px))+(((-1.0)*x801*x809))+(((0.6)*x803))+((x807*x808))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x830=(r02*sj4);
IkReal x831=(cj4*r02);
IkReal x832=(cj4*r22);
IkReal x833=(cj5*sj4);
IkReal x834=(sj4*sj5);
IkReal x835=((0.12)*x830);
IkReal x836=((1.8)*x831);
IkReal x837=((0.04)*x830);
IkReal x838=((0.6)*x831);
IkReal x839=(cj4*r01*sj5);
IkReal x840=(cj4*cj5*r00);
IkReal x841=((0.12)*x840);
IkReal x842=((2.28)*r20*x833);
IkReal x843=((1.8)*r01*x834);
IkReal x844=((0.76)*r20*x833);
IkReal x845=((0.04)*x840);
IkReal x846=((0.6)*r01*x834);
IkReal x847=((((12.0)*px))+(((2.28)*x832))+(((0.12)*x839))+(((2.28)*r21*x834))+(((1.8)*r00*x833)));
IkReal x848=((((0.6)*r00*x833))+(((4.0)*px))+(((0.04)*x839))+(((0.76)*x832))+(((0.76)*r21*x834)));
IkReal x849=(x835+x836+x841+x843+x842);
IkReal x850=(x837+x838+x845+x844+x846);
op[0]=((-0.24)+(((-1.0)*x848))+x850);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x847))+x849);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x847))+x849);
op[5]=-1.36;
op[6]=((((-1.0)*x848))+x850);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x851=(cj5*sj4);
IkReal x852=(sj4*sj5);
IkReal x853=(cj4*r02);
IkReal x854=(r22*sj4);
IkReal x855=(cj4*r22);
IkReal x856=((0.12)*x854);
IkReal x857=((1.8)*x855);
IkReal x858=((2.28)*x853);
IkReal x859=((0.6)*x855);
IkReal x860=((0.76)*x853);
IkReal x861=((0.04)*x854);
IkReal x862=(cj4*cj5*r20);
IkReal x863=(cj4*r21*sj5);
IkReal x864=((2.28)*r01*x852);
IkReal x865=((1.8)*r21*x852);
IkReal x866=((0.12)*x862);
IkReal x867=((0.04)*x862);
IkReal x868=((0.6)*r21*x852);
IkReal x869=((0.76)*r01*x852);
IkReal x870=((((12.0)*pz))+(((0.12)*x863))+(((1.8)*r20*x851))+(((2.28)*r00*x851)));
IkReal x871=((((4.0)*pz))+(((0.6)*r20*x851))+(((0.04)*x863))+(((0.76)*r00*x851)));
IkReal x872=(x856+x857+x858+x866+x865+x864);
IkReal x873=(x859+x869+x868+x867+x861+x860);
j1evalpoly[0]=((0.68)+(((0.48)*(htj1*htj1*htj1)))+(((htj1*htj1)*(((0.68)+x872+(((-1.0)*x870))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.68)+x873+(((-1.0)*x871))))))+(((0.24)*htj1))+x873+(((htj1*htj1*htj1*htj1)*(((-0.68)+x872+(((-1.0)*x870))))))+(((0.24)*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x871)));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x874=(sj1*sj4);
IkReal x875=(r01*sj5);
IkReal x876=((1.0)*cj1);
IkReal x877=(cj4*r22);
IkReal x878=(cj4*r02);
IkReal x879=(cj5*r20);
IkReal x880=(cj1*sj4);
IkReal x881=(cj5*r00);
IkReal x882=(r21*sj5);
if( IKabs(((((-1.0)*x876*x877))+((x879*x880))+((x874*x875))+((sj1*x878))+(((-1.0)*x874*x881))+(((-1.0)*sj4*x876*x882)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x876*x878))+((x880*x881))+((x874*x879))+(((-1.0)*x874*x882))+(((-1.0)*sj4*x875*x876))+(((-1.0)*sj1*x877)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x876*x877))+((x879*x880))+((x874*x875))+((sj1*x878))+(((-1.0)*x874*x881))+(((-1.0)*sj4*x876*x882))))+IKsqr(((((-1.0)*x876*x878))+((x880*x881))+((x874*x879))+(((-1.0)*x874*x882))+(((-1.0)*sj4*x875*x876))+(((-1.0)*sj1*x877))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x876*x877))+((x879*x880))+((x874*x875))+((sj1*x878))+(((-1.0)*x874*x881))+(((-1.0)*sj4*x876*x882))), ((((-1.0)*x876*x878))+((x880*x881))+((x874*x879))+(((-1.0)*x874*x882))+(((-1.0)*sj4*x875*x876))+(((-1.0)*sj1*x877))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x883=IKcos(j2);
IkReal x884=IKsin(j2);
IkReal x885=((0.15)*sj1);
IkReal x886=((1.0)*cj3);
IkReal x887=(r02*sj4);
IkReal x888=(cj5*r00);
IkReal x889=(r01*sj5);
IkReal x890=((1.0)*sj4);
IkReal x891=(cj5*sj3);
IkReal x892=(sj3*sj5);
IkReal x893=((1.0)*cj4);
IkReal x894=((0.01)*cj4);
IkReal x895=(r21*sj5);
IkReal x896=(r22*sj4);
IkReal x897=(sj1*x884);
IkReal x898=(cj3*cj4*sj5);
IkReal x899=(cj1*x883);
IkReal x900=(cj1*x884);
IkReal x901=(cj4*cj5*r20);
IkReal x902=(sj1*x883);
IkReal x903=((1.0)*x899);
evalcond[0]=(((sj4*x888))+(((-1.0)*x903))+(((-1.0)*x889*x890))+(((-1.0)*r02*x893))+x897);
evalcond[1]=(((cj5*r20*sj4))+(((-1.0)*x902))+(((-1.0)*x900))+(((-1.0)*r22*x893))+(((-1.0)*x890*x895)));
evalcond[2]=((((-1.0)*x886*x887))+((r01*x891))+((r00*x892))+(((-1.0)*cj4*x886*x888))+x900+x902+((cj3*cj4*x889)));
evalcond[3]=(((r20*x892))+(((-1.0)*x903))+(((-1.0)*x886*x901))+((r21*x891))+x897+((cj3*cj4*x895))+(((-1.0)*x886*x896)));
evalcond[4]=((((0.17)*cj1))+(((-1.0)*x883*x885))+(((0.03)*sj1))+(((0.19)*x897))+(((-1.0)*pz))+(((-0.19)*x899))+(((-1.0)*x894*x895))+((cj5*r20*x894))+(((-0.15)*x900))+(((0.01)*x896)));
evalcond[5]=((-0.03)+(((0.03)*cj1))+(((-1.0)*px))+(((-1.0)*x889*x894))+(((-0.17)*sj1))+(((0.01)*x887))+((x888*x894))+(((0.19)*x902))+(((0.19)*x900))+(((-0.15)*x899))+((x884*x885)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x904=((1.0)*r11);
IkReal x905=(((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)));
j3eval[0]=x905;
j3eval[1]=IKsign(x905);
j3eval[2]=((IKabs((((cj4*cj5*r10))+(((-1.0)*cj4*sj5*x904))+((r12*sj4)))))+(IKabs(((((-1.0)*r10*sj5))+(((-1.0)*cj5*x904))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x906=((1.0)*sj5);
IkReal x907=(((cj5*r10*sj4))+(((-1.0)*r11*sj4*x906))+(((-1.0)*cj4*r12)));
j3eval[0]=x907;
j3eval[1]=((IKabs(((((-1.0)*r20*x906))+(((-1.0)*cj5*r21)))))+(IKabs(((((-1.0)*cj4*r21*x906))+((r22*sj4))+((cj4*cj5*r20))))));
j3eval[2]=IKsign(x907);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x908=r00*r00;
IkReal x909=cj5*cj5;
IkReal x910=cj4*cj4;
IkReal x911=r01*r01;
IkReal x912=r02*r02;
IkReal x913=(cj5*r00);
IkReal x914=(r02*sj4);
IkReal x915=((2.0)*r01*sj5);
IkReal x916=((1.0)*x910);
IkReal x917=(x908*x909);
IkReal x918=(x909*x911);
IkReal x919=(((x910*x911))+((x910*x917))+(((-1.0)*x910*x913*x915))+(((2.0)*cj4*x913*x914))+(((-1.0)*cj4*x914*x915))+(((-1.0)*x917))+(((-1.0)*x912*x916))+((x913*x915))+x918+x912+x908+(((-1.0)*x916*x918)));
j3eval[0]=x919;
j3eval[1]=((IKabs(((((-1.0)*r00*sj5))+(((-1.0)*cj5*r01)))))+(IKabs(((((-1.0)*x914))+((cj4*r01*sj5))+(((-1.0)*cj4*x913))))));
j3eval[2]=IKsign(x919);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x920=r00*r00;
IkReal x921=cj5*cj5;
IkReal x922=cj4*cj4;
IkReal x923=r01*r01;
IkReal x924=r02*r02;
IkReal x925=(cj5*r00);
IkReal x926=(r02*sj4);
IkReal x927=((2.0)*r01*sj5);
IkReal x928=((1.0)*x922);
IkReal x929=(x920*x921);
IkReal x930=(x921*x923);
CheckValue<IkReal> x931 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*x925))+(((-1.0)*x926))+((cj4*r01*sj5)))),IkReal(((((-1.0)*r00*sj5))+(((-1.0)*cj5*r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x931.valid){
continue;
}
CheckValue<IkReal> x932=IKPowWithIntegerCheck(IKsign(((((-1.0)*x922*x925*x927))+(((2.0)*cj4*x925*x926))+(((-1.0)*x928*x930))+(((-1.0)*x924*x928))+(((-1.0)*x929))+(((-1.0)*cj4*x926*x927))+((x922*x923))+((x922*x929))+((x925*x927))+x930+x924+x920)),-1);
if(!x932.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x931.value)+(((1.5707963267949)*(x932.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x933=IKsin(j3);
IkReal x934=IKcos(j3);
IkReal x935=(r02*sj4);
IkReal x936=(cj4*cj5);
IkReal x937=(cj4*sj5);
IkReal x938=(cj5*r01);
IkReal x939=(r00*sj5);
IkReal x940=((1.0)*x934);
IkReal x941=((1.0)*x933);
evalcond[0]=(((r01*x934*x937))+(((-1.0)*r00*x936*x940))+(((-1.0)*x935*x940))+((x933*x939))+((x933*x938)));
evalcond[1]=((((-1.0)*r22*sj4*x941))+((r21*x933*x937))+(((-1.0)*cj5*r21*x940))+(((-1.0)*r20*x936*x941))+(((-1.0)*r20*sj5*x940)));
evalcond[2]=((((-1.0)*r12*sj4*x941))+(((-1.0)*r10*x936*x941))+(((-1.0)*r10*sj5*x940))+((r11*x933*x937))+(((-1.0)*cj5*r11*x940)));
evalcond[3]=((-1.0)+((r01*x933*x937))+(((-1.0)*x939*x940))+(((-1.0)*x938*x940))+(((-1.0)*r00*x936*x941))+(((-1.0)*x935*x941)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x942=((12.0)*pz);
IkReal x943=((12.0)*py);
IkReal x944=(r11*sj5);
IkReal x945=((0.76)*sj4);
IkReal x946=(cj5*r20);
IkReal x947=((0.6)*sj4);
IkReal x948=(cj4*r22);
IkReal x949=((0.04)*cj4);
IkReal x950=(r22*sj4);
IkReal x951=(cj4*r12);
IkReal x952=((2.28)*sj4);
IkReal x953=((1.8)*sj4);
IkReal x954=((0.12)*cj4);
IkReal x955=(cj5*r10);
IkReal x956=(r12*sj4);
IkReal x957=(r21*sj5);
IkReal x958=((2.28)*x951);
IkReal x959=(x944*x952);
IkReal x960=(x946*x953);
IkReal x961=(x954*x957);
IkReal x962=(x946*x952);
IkReal x963=(x953*x955);
IkReal x964=(x944*x954);
IkReal x965=(x962+x963+x964+x943);
IkReal x966=(x960+x961+x959+x958+x942);
IkReal x967=((((0.12)*x950))+((x952*x955))+((x946*x954))+((x953*x957))+(((1.8)*x948)));
IkReal x968=((((0.12)*x956))+((x952*x957))+((x944*x953))+(((1.8)*x951))+(((2.28)*x948))+((x954*x955)));
j1eval[0]=((6.4)+(IKabs(((-0.24)+x965+(((-1.0)*x968)))))+(IKabs(((-0.68)+x966+(((-1.0)*x967)))))+(IKabs(((0.68)+x966+(((-1.0)*x967)))))+(IKabs(((0.68)+(((-0.6)*x948))+((x946*x947))+(((4.0)*pz))+(((0.76)*x951))+(((-0.04)*x950))+((x949*x957))+(((-1.0)*x946*x949))+(((-1.0)*x947*x957))+((x944*x945))+(((-1.0)*x945*x955)))))+(IKabs(((-0.48)+x965+(((-1.0)*x968)))))+(IKabs(((-0.24)+(((4.0)*py))+((x945*x946))+(((-0.04)*x956))+(((-1.0)*x944*x947))+((x947*x955))+(((-0.76)*x948))+((x944*x949))+(((-1.0)*x949*x955))+(((-1.0)*x945*x957))+(((-0.6)*x951))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x969=((12.0)*py);
IkReal x970=((4.0)*py);
IkReal x971=((1.8)*sj4);
IkReal x972=(r11*sj5);
IkReal x973=(cj4*r22);
IkReal x974=(cj5*r10);
IkReal x975=((0.12)*cj4);
IkReal x976=(r12*sj4);
IkReal x977=((0.04)*cj4);
IkReal x978=(cj4*r12);
IkReal x979=((0.6)*sj4);
IkReal x980=(cj5*r20*sj4);
IkReal x981=(r21*sj4*sj5);
IkReal x982=((2.28)*x980);
IkReal x983=(x971*x974);
IkReal x984=(x972*x975);
IkReal x985=(x972*x977);
IkReal x986=((0.76)*x980);
IkReal x987=(x974*x979);
IkReal x988=(x985+x986+x987+x970);
IkReal x989=(x984+x982+x983+x969);
IkReal x990=((((0.12)*x976))+(((2.28)*x973))+(((2.28)*x981))+(((1.8)*x978))+((x971*x972))+((x974*x975)));
IkReal x991=((((0.04)*x976))+(((0.76)*x981))+(((0.76)*x973))+(((0.6)*x978))+((x974*x977))+((x972*x979)));
op[0]=((-0.24)+(((-1.0)*x991))+x988);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x990))+x989);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x990))+x989);
op[5]=-1.36;
op[6]=((((-1.0)*x991))+x988);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x992=((4.0)*pz);
IkReal x993=((12.0)*pz);
IkReal x994=(r22*sj4);
IkReal x995=(cj4*r22);
IkReal x996=(cj4*r12);
IkReal x997=(r21*sj5);
IkReal x998=((0.76)*x996);
IkReal x999=((2.28)*x996);
IkReal x1000=((0.6)*x995);
IkReal x1001=((0.04)*x994);
IkReal x1002=(r11*sj4*sj5);
IkReal x1003=(cj5*r20*sj4);
IkReal x1004=(cj4*cj5*r20);
IkReal x1005=(cj5*r10*sj4);
IkReal x1006=((0.6)*x1003);
IkReal x1007=((0.04)*cj4*x997);
IkReal x1008=((2.28)*x1002);
IkReal x1009=((1.8)*x1003);
IkReal x1010=((0.12)*cj4*x997);
IkReal x1011=((0.76)*x1002);
IkReal x1012=((0.04)*x1004);
IkReal x1013=((0.76)*x1005);
IkReal x1014=((0.6)*sj4*x997);
IkReal x1015=(x1011+x1007+x1006+x992+x998);
IkReal x1016=(x1010+x1009+x1008+x993+x999);
IkReal x1017=((((0.12)*x994))+(((2.28)*x1005))+(((1.8)*x995))+(((0.12)*x1004))+(((1.8)*sj4*x997)));
IkReal x1018=(x1014+x1012+x1013+x1001+x1000);
j1evalpoly[0]=((-0.68)+(((-0.24)*htj1))+x1015+(((-1.0)*x1018))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.68)+x1015+(((-1.0)*x1018))))))+(((-0.24)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.48)*(htj1*htj1*htj1)))+(((htj1*htj1)*(((-0.68)+x1016+(((-1.0)*x1017))))))+(((htj1*htj1*htj1*htj1)*(((0.68)+x1016+(((-1.0)*x1017)))))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1019=(cj1*cj4);
IkReal x1020=((1.0)*r22);
IkReal x1021=(cj5*sj4);
IkReal x1022=((1.0)*cj1);
IkReal x1023=((1.0)*sj1);
IkReal x1024=(sj4*sj5);
if( IKabs(((((-1.0)*r21*x1022*x1024))+((r10*sj1*x1021))+(((-1.0)*x1019*x1020))+(((-1.0)*cj4*r12*x1023))+(((-1.0)*r11*x1023*x1024))+((cj1*r20*x1021)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r20*sj1*x1021))+(((-1.0)*r10*x1021*x1022))+(((-1.0)*r21*x1023*x1024))+((cj1*r11*x1024))+((r12*x1019))+(((-1.0)*cj4*sj1*x1020)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r21*x1022*x1024))+((r10*sj1*x1021))+(((-1.0)*x1019*x1020))+(((-1.0)*cj4*r12*x1023))+(((-1.0)*r11*x1023*x1024))+((cj1*r20*x1021))))+IKsqr((((r20*sj1*x1021))+(((-1.0)*r10*x1021*x1022))+(((-1.0)*r21*x1023*x1024))+((cj1*r11*x1024))+((r12*x1019))+(((-1.0)*cj4*sj1*x1020))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r21*x1022*x1024))+((r10*sj1*x1021))+(((-1.0)*x1019*x1020))+(((-1.0)*cj4*r12*x1023))+(((-1.0)*r11*x1023*x1024))+((cj1*r20*x1021))), (((r20*sj1*x1021))+(((-1.0)*r10*x1021*x1022))+(((-1.0)*r21*x1023*x1024))+((cj1*r11*x1024))+((r12*x1019))+(((-1.0)*cj4*sj1*x1020))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1025=IKcos(j2);
IkReal x1026=IKsin(j2);
IkReal x1027=((0.15)*sj1);
IkReal x1028=(cj3*cj4);
IkReal x1029=(r21*sj5);
IkReal x1030=(r12*sj4);
IkReal x1031=((1.0)*cj3);
IkReal x1032=((1.0)*cj5);
IkReal x1033=(cj5*sj3);
IkReal x1034=((1.0)*sj1);
IkReal x1035=(cj5*sj4);
IkReal x1036=((1.0)*cj4);
IkReal x1037=((0.19)*sj1);
IkReal x1038=(sj3*sj5);
IkReal x1039=((0.01)*cj4);
IkReal x1040=(r11*sj5);
IkReal x1041=((1.0)*sj4);
IkReal x1042=(r22*sj4);
IkReal x1043=(cj1*x1025);
IkReal x1044=(cj1*x1026);
IkReal x1045=(x1025*x1034);
IkReal x1046=((1.0)*x1044);
IkReal x1047=(x1046+x1045);
evalcond[0]=(((r10*x1035))+x1043+(((-1.0)*x1026*x1034))+(((-1.0)*r12*x1036))+(((-1.0)*x1040*x1041)));
evalcond[1]=((((-1.0)*x1029*x1041))+((r20*x1035))+(((-1.0)*r22*x1036))+(((-1.0)*x1047)));
evalcond[2]=(((sj1*x1026))+(((-1.0)*x1031*x1042))+((x1028*x1029))+((r21*x1033))+((r20*x1038))+(((-1.0)*x1043))+(((-1.0)*r20*x1028*x1032)));
evalcond[3]=(((r10*x1038))+((x1028*x1040))+((r11*x1033))+(((-1.0)*x1030*x1031))+(((-1.0)*x1047))+(((-1.0)*r10*x1028*x1032)));
evalcond[4]=((((0.17)*cj1))+(((0.03)*sj1))+((x1026*x1037))+(((-1.0)*x1029*x1039))+(((-0.19)*x1043))+(((-1.0)*pz))+((cj5*r20*x1039))+(((-0.15)*x1044))+(((-1.0)*x1025*x1027))+(((0.01)*x1042)));
evalcond[5]=((0.03)+(((0.01)*x1030))+(((-1.0)*x1025*x1037))+((cj5*r10*x1039))+(((-1.0)*x1026*x1027))+(((0.17)*sj1))+(((-1.0)*x1039*x1040))+(((-0.19)*x1044))+(((-1.0)*py))+(((0.15)*x1043))+(((-0.03)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1048=((1.0)*sj5);
CheckValue<IkReal> x1049 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r21))+(((-1.0)*r20*x1048)))),IkReal((((r22*sj4))+(((-1.0)*cj4*r21*x1048))+((cj4*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1049.valid){
continue;
}
CheckValue<IkReal> x1050=IKPowWithIntegerCheck(IKsign(((((-1.0)*r11*sj4*x1048))+((cj5*r10*sj4))+(((-1.0)*cj4*r12)))),-1);
if(!x1050.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1049.value)+(((1.5707963267949)*(x1050.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1051=IKsin(j3);
IkReal x1052=IKcos(j3);
IkReal x1053=(r02*sj4);
IkReal x1054=(cj4*cj5);
IkReal x1055=(cj4*sj5);
IkReal x1056=(cj5*r01);
IkReal x1057=(r00*sj5);
IkReal x1058=((1.0)*x1052);
IkReal x1059=((1.0)*x1051);
evalcond[0]=((((-1.0)*r00*x1054*x1058))+((x1051*x1057))+((x1051*x1056))+(((-1.0)*x1053*x1058))+((r01*x1052*x1055)));
evalcond[1]=((((-1.0)*cj5*r21*x1058))+(((-1.0)*r20*sj5*x1058))+((r21*x1051*x1055))+(((-1.0)*r22*sj4*x1059))+(((-1.0)*r20*x1054*x1059)));
evalcond[2]=((((-1.0)*r10*x1054*x1059))+(((-1.0)*r10*sj5*x1058))+(((-1.0)*cj5*r11*x1058))+((r11*x1051*x1055))+(((-1.0)*r12*sj4*x1059)));
evalcond[3]=((-1.0)+((r01*x1051*x1055))+(((-1.0)*r00*x1054*x1059))+(((-1.0)*x1056*x1058))+(((-1.0)*x1057*x1058))+(((-1.0)*x1053*x1059)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x1060=((12.0)*pz);
IkReal x1061=((12.0)*py);
IkReal x1062=(r11*sj5);
IkReal x1063=((0.76)*sj4);
IkReal x1064=(cj5*r20);
IkReal x1065=((0.6)*sj4);
IkReal x1066=(cj4*r22);
IkReal x1067=((0.04)*cj4);
IkReal x1068=(r22*sj4);
IkReal x1069=(cj4*r12);
IkReal x1070=((2.28)*sj4);
IkReal x1071=((1.8)*sj4);
IkReal x1072=((0.12)*cj4);
IkReal x1073=(cj5*r10);
IkReal x1074=(r12*sj4);
IkReal x1075=(r21*sj5);
IkReal x1076=((2.28)*x1069);
IkReal x1077=(x1062*x1070);
IkReal x1078=(x1064*x1071);
IkReal x1079=(x1072*x1075);
IkReal x1080=(x1064*x1070);
IkReal x1081=(x1071*x1073);
IkReal x1082=(x1062*x1072);
IkReal x1083=(x1061+x1082+x1081+x1080);
IkReal x1084=(x1078+x1079+x1076+x1077+x1060);
IkReal x1085=(((x1070*x1073))+((x1071*x1075))+(((0.12)*x1068))+(((1.8)*x1066))+((x1064*x1072)));
IkReal x1086=((((2.28)*x1066))+((x1070*x1075))+((x1062*x1071))+((x1072*x1073))+(((0.12)*x1074))+(((1.8)*x1069)));
j1eval[0]=((6.4)+(IKabs(((-0.24)+(((-1.0)*x1063*x1075))+(((-0.04)*x1074))+(((4.0)*py))+(((-0.76)*x1066))+(((-1.0)*x1062*x1065))+((x1062*x1067))+(((-0.6)*x1069))+(((-1.0)*x1067*x1073))+((x1063*x1064))+((x1065*x1073)))))+(IKabs(((-0.48)+x1083+(((-1.0)*x1086)))))+(IKabs(((0.68)+(((-1.0)*x1063*x1073))+(((4.0)*pz))+((x1067*x1075))+(((0.76)*x1069))+((x1062*x1063))+(((-0.6)*x1066))+(((-1.0)*x1064*x1067))+(((-1.0)*x1065*x1075))+((x1064*x1065))+(((-0.04)*x1068)))))+(IKabs(((-0.68)+x1084+(((-1.0)*x1085)))))+(IKabs(((0.68)+x1084+(((-1.0)*x1085)))))+(IKabs(((-0.24)+x1083+(((-1.0)*x1086))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1087=((12.0)*py);
IkReal x1088=((4.0)*py);
IkReal x1089=((1.8)*sj4);
IkReal x1090=(r11*sj5);
IkReal x1091=(cj4*r22);
IkReal x1092=(cj5*r10);
IkReal x1093=((0.12)*cj4);
IkReal x1094=(r12*sj4);
IkReal x1095=((0.04)*cj4);
IkReal x1096=(cj4*r12);
IkReal x1097=((0.6)*sj4);
IkReal x1098=(cj5*r20*sj4);
IkReal x1099=(r21*sj4*sj5);
IkReal x1100=((2.28)*x1098);
IkReal x1101=(x1089*x1092);
IkReal x1102=(x1090*x1093);
IkReal x1103=(x1090*x1095);
IkReal x1104=((0.76)*x1098);
IkReal x1105=(x1092*x1097);
IkReal x1106=(x1104+x1105+x1103+x1088);
IkReal x1107=(x1102+x1100+x1101+x1087);
IkReal x1108=(((x1089*x1090))+(((0.12)*x1094))+(((1.8)*x1096))+(((2.28)*x1091))+(((2.28)*x1099))+((x1092*x1093)));
IkReal x1109=((((0.76)*x1091))+(((0.76)*x1099))+(((0.6)*x1096))+((x1092*x1095))+(((0.04)*x1094))+((x1090*x1097)));
op[0]=((-0.24)+x1106+(((-1.0)*x1109)));
op[1]=-1.36;
op[2]=((-0.48)+x1107+(((-1.0)*x1108)));
op[3]=-2.72;
op[4]=((-0.24)+x1107+(((-1.0)*x1108)));
op[5]=-1.36;
op[6]=(x1106+(((-1.0)*x1109)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1110=((4.0)*pz);
IkReal x1111=((12.0)*pz);
IkReal x1112=(r22*sj4);
IkReal x1113=(cj4*r22);
IkReal x1114=(cj4*r12);
IkReal x1115=(r21*sj5);
IkReal x1116=((0.76)*x1114);
IkReal x1117=((2.28)*x1114);
IkReal x1118=((0.6)*x1113);
IkReal x1119=((0.04)*x1112);
IkReal x1120=(r11*sj4*sj5);
IkReal x1121=(cj5*r20*sj4);
IkReal x1122=(cj4*cj5*r20);
IkReal x1123=(cj5*r10*sj4);
IkReal x1124=((0.6)*x1121);
IkReal x1125=((0.04)*cj4*x1115);
IkReal x1126=((2.28)*x1120);
IkReal x1127=((1.8)*x1121);
IkReal x1128=((0.12)*cj4*x1115);
IkReal x1129=((0.76)*x1120);
IkReal x1130=((0.04)*x1122);
IkReal x1131=((0.76)*x1123);
IkReal x1132=((0.6)*sj4*x1115);
IkReal x1133=(x1110+x1116+x1129+x1124+x1125);
IkReal x1134=(x1111+x1117+x1128+x1126+x1127);
IkReal x1135=((((2.28)*x1123))+(((0.12)*x1122))+(((1.8)*x1113))+(((0.12)*x1112))+(((1.8)*sj4*x1115)));
IkReal x1136=(x1119+x1118+x1132+x1131+x1130);
j1evalpoly[0]=((-0.68)+x1133+(((-0.24)*htj1))+(((htj1*htj1)*(((-0.68)+x1134+(((-1.0)*x1135))))))+(((-0.24)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.48)*(htj1*htj1*htj1)))+(((-1.0)*x1136))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.68)+x1133+(((-1.0)*x1136))))))+(((htj1*htj1*htj1*htj1)*(((0.68)+x1134+(((-1.0)*x1135)))))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1137=(cj1*cj4);
IkReal x1138=((1.0)*r22);
IkReal x1139=(cj5*sj4);
IkReal x1140=((1.0)*cj1);
IkReal x1141=((1.0)*sj1);
IkReal x1142=(sj4*sj5);
if( IKabs(((((-1.0)*r11*x1141*x1142))+((cj1*r20*x1139))+(((-1.0)*cj4*r12*x1141))+(((-1.0)*x1137*x1138))+(((-1.0)*r21*x1140*x1142))+((r10*sj1*x1139)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj4*sj1*x1138))+(((-1.0)*r21*x1141*x1142))+(((-1.0)*r10*x1139*x1140))+((cj1*r11*x1142))+((r20*sj1*x1139))+((r12*x1137)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r11*x1141*x1142))+((cj1*r20*x1139))+(((-1.0)*cj4*r12*x1141))+(((-1.0)*x1137*x1138))+(((-1.0)*r21*x1140*x1142))+((r10*sj1*x1139))))+IKsqr(((((-1.0)*cj4*sj1*x1138))+(((-1.0)*r21*x1141*x1142))+(((-1.0)*r10*x1139*x1140))+((cj1*r11*x1142))+((r20*sj1*x1139))+((r12*x1137))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r11*x1141*x1142))+((cj1*r20*x1139))+(((-1.0)*cj4*r12*x1141))+(((-1.0)*x1137*x1138))+(((-1.0)*r21*x1140*x1142))+((r10*sj1*x1139))), ((((-1.0)*cj4*sj1*x1138))+(((-1.0)*r21*x1141*x1142))+(((-1.0)*r10*x1139*x1140))+((cj1*r11*x1142))+((r20*sj1*x1139))+((r12*x1137))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1143=IKcos(j2);
IkReal x1144=IKsin(j2);
IkReal x1145=((0.15)*sj1);
IkReal x1146=(cj3*cj4);
IkReal x1147=(r21*sj5);
IkReal x1148=(r12*sj4);
IkReal x1149=((1.0)*cj3);
IkReal x1150=((1.0)*cj5);
IkReal x1151=(cj5*sj3);
IkReal x1152=((1.0)*sj1);
IkReal x1153=(cj5*sj4);
IkReal x1154=((1.0)*cj4);
IkReal x1155=((0.19)*sj1);
IkReal x1156=(sj3*sj5);
IkReal x1157=((0.01)*cj4);
IkReal x1158=(r11*sj5);
IkReal x1159=((1.0)*sj4);
IkReal x1160=(r22*sj4);
IkReal x1161=(cj1*x1143);
IkReal x1162=(cj1*x1144);
IkReal x1163=(x1143*x1152);
IkReal x1164=((1.0)*x1162);
IkReal x1165=(x1164+x1163);
evalcond[0]=((((-1.0)*x1144*x1152))+x1161+(((-1.0)*x1158*x1159))+(((-1.0)*r12*x1154))+((r10*x1153)));
evalcond[1]=((((-1.0)*x1147*x1159))+((r20*x1153))+(((-1.0)*r22*x1154))+(((-1.0)*x1165)));
evalcond[2]=((((-1.0)*r20*x1146*x1150))+((x1146*x1147))+(((-1.0)*x1149*x1160))+((r20*x1156))+((sj1*x1144))+((r21*x1151))+(((-1.0)*x1161)));
evalcond[3]=(((r11*x1151))+((x1146*x1158))+(((-1.0)*x1148*x1149))+(((-1.0)*r10*x1146*x1150))+(((-1.0)*x1165))+((r10*x1156)));
evalcond[4]=((((0.17)*cj1))+(((-1.0)*x1143*x1145))+(((0.03)*sj1))+(((0.01)*x1160))+(((-0.19)*x1161))+(((-1.0)*x1147*x1157))+(((-1.0)*pz))+(((-0.15)*x1162))+((x1144*x1155))+((cj5*r20*x1157)));
evalcond[5]=((0.03)+(((-1.0)*x1157*x1158))+((cj5*r10*x1157))+(((-1.0)*x1143*x1155))+(((0.17)*sj1))+(((-0.19)*x1162))+(((-1.0)*py))+(((0.01)*x1148))+(((-1.0)*x1144*x1145))+(((-0.03)*cj1))+(((0.15)*x1161)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1166=((1.0)*r11);
CheckValue<IkReal> x1167=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*cj5*r20*sj4)))),-1);
if(!x1167.valid){
continue;
}
CheckValue<IkReal> x1168 = IKatan2WithCheck(IkReal(((((-1.0)*r10*sj5))+(((-1.0)*cj5*x1166)))),IkReal((((cj4*cj5*r10))+((r12*sj4))+(((-1.0)*cj4*sj5*x1166)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1168.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1167.value)))+(x1168.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1169=IKsin(j3);
IkReal x1170=IKcos(j3);
IkReal x1171=(r02*sj4);
IkReal x1172=(cj4*cj5);
IkReal x1173=(cj4*sj5);
IkReal x1174=(cj5*r01);
IkReal x1175=(r00*sj5);
IkReal x1176=((1.0)*x1170);
IkReal x1177=((1.0)*x1169);
evalcond[0]=(((r01*x1170*x1173))+(((-1.0)*r00*x1172*x1176))+(((-1.0)*x1171*x1176))+((x1169*x1175))+((x1169*x1174)));
evalcond[1]=((((-1.0)*cj5*r21*x1176))+(((-1.0)*r20*sj5*x1176))+(((-1.0)*r22*sj4*x1177))+((r21*x1169*x1173))+(((-1.0)*r20*x1172*x1177)));
evalcond[2]=((((-1.0)*r10*sj5*x1176))+((r11*x1169*x1173))+(((-1.0)*r12*sj4*x1177))+(((-1.0)*r10*x1172*x1177))+(((-1.0)*cj5*r11*x1176)));
evalcond[3]=((-1.0)+(((-1.0)*r00*x1172*x1177))+((r01*x1169*x1173))+(((-1.0)*x1171*x1177))+(((-1.0)*x1175*x1176))+(((-1.0)*x1174*x1176)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x1178=((12.0)*pz);
IkReal x1179=((12.0)*py);
IkReal x1180=(r11*sj5);
IkReal x1181=((0.76)*sj4);
IkReal x1182=(cj5*r20);
IkReal x1183=((0.6)*sj4);
IkReal x1184=(cj4*r22);
IkReal x1185=((0.04)*cj4);
IkReal x1186=(r22*sj4);
IkReal x1187=(cj4*r12);
IkReal x1188=((2.28)*sj4);
IkReal x1189=((1.8)*sj4);
IkReal x1190=((0.12)*cj4);
IkReal x1191=(cj5*r10);
IkReal x1192=(r12*sj4);
IkReal x1193=(r21*sj5);
IkReal x1194=((2.28)*x1187);
IkReal x1195=(x1180*x1188);
IkReal x1196=(x1182*x1189);
IkReal x1197=(x1190*x1193);
IkReal x1198=(x1182*x1188);
IkReal x1199=(x1189*x1191);
IkReal x1200=(x1180*x1190);
IkReal x1201=(x1199+x1198+x1179+x1200);
IkReal x1202=(x1195+x1194+x1197+x1196+x1178);
IkReal x1203=(((x1182*x1190))+((x1188*x1191))+((x1189*x1193))+(((0.12)*x1186))+(((1.8)*x1184)));
IkReal x1204=(((x1180*x1189))+(((0.12)*x1192))+((x1188*x1193))+(((2.28)*x1184))+(((1.8)*x1187))+((x1190*x1191)));
j1eval[0]=((6.4)+(IKabs(((0.68)+(((-1.0)*x1181*x1191))+(((-0.6)*x1184))+((x1182*x1183))+(((4.0)*pz))+(((0.76)*x1187))+((x1180*x1181))+(((-0.04)*x1186))+((x1185*x1193))+(((-1.0)*x1183*x1193))+(((-1.0)*x1182*x1185)))))+(IKabs(((-0.24)+x1201+(((-1.0)*x1204)))))+(IKabs(((0.68)+x1202+(((-1.0)*x1203)))))+(IKabs(((-0.48)+x1201+(((-1.0)*x1204)))))+(IKabs(((-0.68)+x1202+(((-1.0)*x1203)))))+(IKabs(((-0.24)+(((-1.0)*x1181*x1193))+(((-0.6)*x1187))+(((4.0)*py))+((x1183*x1191))+((x1180*x1185))+(((-0.04)*x1192))+(((-1.0)*x1180*x1183))+((x1181*x1182))+(((-0.76)*x1184))+(((-1.0)*x1185*x1191))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1205=((12.0)*py);
IkReal x1206=((4.0)*py);
IkReal x1207=((1.8)*sj4);
IkReal x1208=(r11*sj5);
IkReal x1209=(cj4*r22);
IkReal x1210=(cj5*r10);
IkReal x1211=((0.12)*cj4);
IkReal x1212=(r12*sj4);
IkReal x1213=((0.04)*cj4);
IkReal x1214=(cj4*r12);
IkReal x1215=((0.6)*sj4);
IkReal x1216=(cj5*r20*sj4);
IkReal x1217=(r21*sj4*sj5);
IkReal x1218=((2.28)*x1216);
IkReal x1219=(x1207*x1210);
IkReal x1220=(x1208*x1211);
IkReal x1221=(x1208*x1213);
IkReal x1222=((0.76)*x1216);
IkReal x1223=(x1210*x1215);
IkReal x1224=(x1206+x1223+x1222+x1221);
IkReal x1225=(x1205+x1220+x1218+x1219);
IkReal x1226=((((1.8)*x1214))+((x1210*x1211))+(((2.28)*x1209))+(((0.12)*x1212))+(((2.28)*x1217))+((x1207*x1208)));
IkReal x1227=(((x1210*x1213))+(((0.04)*x1212))+(((0.76)*x1209))+((x1208*x1215))+(((0.6)*x1214))+(((0.76)*x1217)));
op[0]=((-0.24)+x1224+(((-1.0)*x1227)));
op[1]=-1.36;
op[2]=((-0.48)+x1225+(((-1.0)*x1226)));
op[3]=-2.72;
op[4]=((-0.24)+x1225+(((-1.0)*x1226)));
op[5]=-1.36;
op[6]=(x1224+(((-1.0)*x1227)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1228=((4.0)*pz);
IkReal x1229=((12.0)*pz);
IkReal x1230=(r22*sj4);
IkReal x1231=(cj4*r22);
IkReal x1232=(cj4*r12);
IkReal x1233=(r21*sj5);
IkReal x1234=((0.76)*x1232);
IkReal x1235=((2.28)*x1232);
IkReal x1236=((0.6)*x1231);
IkReal x1237=((0.04)*x1230);
IkReal x1238=(r11*sj4*sj5);
IkReal x1239=(cj5*r20*sj4);
IkReal x1240=(cj4*cj5*r20);
IkReal x1241=(cj5*r10*sj4);
IkReal x1242=((0.6)*x1239);
IkReal x1243=((0.04)*cj4*x1233);
IkReal x1244=((2.28)*x1238);
IkReal x1245=((1.8)*x1239);
IkReal x1246=((0.12)*cj4*x1233);
IkReal x1247=((0.76)*x1238);
IkReal x1248=((0.04)*x1240);
IkReal x1249=((0.76)*x1241);
IkReal x1250=((0.6)*sj4*x1233);
IkReal x1251=(x1243+x1242+x1247+x1234+x1228);
IkReal x1252=(x1245+x1244+x1246+x1235+x1229);
IkReal x1253=((((0.12)*x1240))+(((2.28)*x1241))+(((1.8)*sj4*x1233))+(((0.12)*x1230))+(((1.8)*x1231)));
IkReal x1254=(x1249+x1248+x1250+x1236+x1237);
j1evalpoly[0]=((-0.68)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.68)+(((-1.0)*x1254))+x1251))))+(((-1.0)*x1254))+x1251+(((-0.24)*htj1))+(((htj1*htj1)*(((-0.68)+(((-1.0)*x1253))+x1252))))+(((htj1*htj1*htj1*htj1)*(((0.68)+(((-1.0)*x1253))+x1252))))+(((-0.24)*(htj1*htj1*htj1*htj1*htj1)))+(((-0.48)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1255=(cj1*cj4);
IkReal x1256=((1.0)*r22);
IkReal x1257=(cj5*sj4);
IkReal x1258=((1.0)*cj1);
IkReal x1259=((1.0)*sj1);
IkReal x1260=(sj4*sj5);
if( IKabs(((((-1.0)*r21*x1258*x1260))+(((-1.0)*cj4*r12*x1259))+(((-1.0)*x1255*x1256))+((cj1*r20*x1257))+(((-1.0)*r11*x1259*x1260))+((r10*sj1*x1257)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r20*sj1*x1257))+(((-1.0)*r21*x1259*x1260))+(((-1.0)*cj4*sj1*x1256))+((r12*x1255))+((cj1*r11*x1260))+(((-1.0)*r10*x1257*x1258)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r21*x1258*x1260))+(((-1.0)*cj4*r12*x1259))+(((-1.0)*x1255*x1256))+((cj1*r20*x1257))+(((-1.0)*r11*x1259*x1260))+((r10*sj1*x1257))))+IKsqr((((r20*sj1*x1257))+(((-1.0)*r21*x1259*x1260))+(((-1.0)*cj4*sj1*x1256))+((r12*x1255))+((cj1*r11*x1260))+(((-1.0)*r10*x1257*x1258))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r21*x1258*x1260))+(((-1.0)*cj4*r12*x1259))+(((-1.0)*x1255*x1256))+((cj1*r20*x1257))+(((-1.0)*r11*x1259*x1260))+((r10*sj1*x1257))), (((r20*sj1*x1257))+(((-1.0)*r21*x1259*x1260))+(((-1.0)*cj4*sj1*x1256))+((r12*x1255))+((cj1*r11*x1260))+(((-1.0)*r10*x1257*x1258))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1261=IKcos(j2);
IkReal x1262=IKsin(j2);
IkReal x1263=((0.15)*sj1);
IkReal x1264=(cj3*cj4);
IkReal x1265=(r21*sj5);
IkReal x1266=(r12*sj4);
IkReal x1267=((1.0)*cj3);
IkReal x1268=((1.0)*cj5);
IkReal x1269=(cj5*sj3);
IkReal x1270=((1.0)*sj1);
IkReal x1271=(cj5*sj4);
IkReal x1272=((1.0)*cj4);
IkReal x1273=((0.19)*sj1);
IkReal x1274=(sj3*sj5);
IkReal x1275=((0.01)*cj4);
IkReal x1276=(r11*sj5);
IkReal x1277=((1.0)*sj4);
IkReal x1278=(r22*sj4);
IkReal x1279=(cj1*x1261);
IkReal x1280=(cj1*x1262);
IkReal x1281=(x1261*x1270);
IkReal x1282=((1.0)*x1280);
IkReal x1283=(x1281+x1282);
evalcond[0]=(x1279+((r10*x1271))+(((-1.0)*r12*x1272))+(((-1.0)*x1276*x1277))+(((-1.0)*x1262*x1270)));
evalcond[1]=((((-1.0)*r22*x1272))+(((-1.0)*x1283))+(((-1.0)*x1265*x1277))+((r20*x1271)));
evalcond[2]=((((-1.0)*x1267*x1278))+((r21*x1269))+((x1264*x1265))+((sj1*x1262))+(((-1.0)*r20*x1264*x1268))+(((-1.0)*x1279))+((r20*x1274)));
evalcond[3]=(((r11*x1269))+((x1264*x1276))+((r10*x1274))+(((-1.0)*x1266*x1267))+(((-1.0)*r10*x1264*x1268))+(((-1.0)*x1283)));
evalcond[4]=((((0.17)*cj1))+(((-0.15)*x1280))+(((-1.0)*x1261*x1263))+(((0.03)*sj1))+(((-1.0)*pz))+((cj5*r20*x1275))+(((0.01)*x1278))+((x1262*x1273))+(((-1.0)*x1265*x1275))+(((-0.19)*x1279)));
evalcond[5]=((0.03)+(((-0.19)*x1280))+(((-1.0)*x1261*x1273))+((cj5*r10*x1275))+(((0.17)*sj1))+(((-1.0)*x1275*x1276))+(((-1.0)*x1262*x1263))+(((-1.0)*py))+(((0.01)*x1266))+(((0.15)*x1279))+(((-0.03)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1284=((1.0)*cj5);
IkReal x1285=((1.0)*sj5);
IkReal x1286=(((r11*sj4*sj5))+(((-1.0)*r10*sj4*x1284))+((cj4*r12)));
j3eval[0]=x1286;
j3eval[1]=((IKabs(((((-1.0)*r21*x1284))+(((-1.0)*r20*x1285)))))+(IKabs((((r22*sj4))+((cj4*cj5*r20))+(((-1.0)*cj4*r21*x1285))))));
j3eval[2]=IKsign(x1286);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1287=((1.0)*r11);
IkReal x1288=((1.0)*sj5);
IkReal x1289=(((cj5*r20*sj4))+(((-1.0)*r21*sj4*x1288))+(((-1.0)*cj4*r22)));
j3eval[0]=x1289;
j3eval[1]=((IKabs(((((-1.0)*r10*x1288))+(((-1.0)*cj5*x1287)))))+(IKabs((((cj4*cj5*r10))+(((-1.0)*cj4*sj5*x1287))+((r12*sj4))))));
j3eval[2]=IKsign(x1289);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1290=cj4*cj4;
IkReal x1291=cj5*cj5;
IkReal x1292=r01*r01;
IkReal x1293=r02*r02;
IkReal x1294=r00*r00;
IkReal x1295=(cj5*r00);
IkReal x1296=(r01*sj5);
IkReal x1297=(r02*sj4);
IkReal x1298=((2.0)*cj4);
IkReal x1299=((1.0)*x1290);
IkReal x1300=(x1291*x1294);
IkReal x1301=(x1291*x1292);
IkReal x1302=(x1300+((x1296*x1297*x1298))+(((-1.0)*x1301))+(((-1.0)*x1299*x1300))+(((-1.0)*x1295*x1297*x1298))+((x1290*x1293))+(((2.0)*x1290*x1295*x1296))+((x1290*x1301))+(((-2.0)*x1295*x1296))+(((-1.0)*x1292*x1299))+(((-1.0)*x1294))+(((-1.0)*x1293)));
j3eval[0]=x1302;
j3eval[1]=IKsign(x1302);
j3eval[2]=((IKabs(((((-1.0)*cj4*x1295))+(((-1.0)*x1297))+((cj4*x1296)))))+(IKabs(((((-1.0)*r00*sj5))+(((-1.0)*cj5*r01))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1303=cj4*cj4;
IkReal x1304=cj5*cj5;
IkReal x1305=r01*r01;
IkReal x1306=r02*r02;
IkReal x1307=r00*r00;
IkReal x1308=((1.0)*cj5);
IkReal x1309=(cj4*r00);
IkReal x1310=(r02*sj4);
IkReal x1311=((2.0)*cj5);
IkReal x1312=(r00*sj5);
IkReal x1313=((1.0)*x1304);
IkReal x1314=(cj4*r01*sj5);
IkReal x1315=(x1303*x1305);
CheckValue<IkReal> x1316 = IKatan2WithCheck(IkReal((x1314+(((-1.0)*x1308*x1309))+(((-1.0)*x1310)))),IkReal(((((-1.0)*r01*x1308))+(((-1.0)*x1312)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1316.valid){
continue;
}
CheckValue<IkReal> x1317=IKPowWithIntegerCheck(IKsign((((r01*x1303*x1311*x1312))+(((-1.0)*x1303*x1307*x1313))+(((-1.0)*x1306))+(((-1.0)*x1307))+(((-1.0)*x1315))+(((-1.0)*x1305*x1313))+((x1303*x1306))+((x1304*x1307))+(((-1.0)*x1309*x1310*x1311))+((x1304*x1315))+(((-1.0)*r01*x1311*x1312))+(((2.0)*x1310*x1314)))),-1);
if(!x1317.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1316.value)+(((1.5707963267949)*(x1317.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1318=IKsin(j3);
IkReal x1319=IKcos(j3);
IkReal x1320=(r02*sj4);
IkReal x1321=(cj4*cj5);
IkReal x1322=(cj4*sj5);
IkReal x1323=(cj5*r01);
IkReal x1324=(r00*sj5);
IkReal x1325=((1.0)*x1319);
IkReal x1326=((1.0)*x1318);
evalcond[0]=((((-1.0)*r00*x1321*x1325))+((r01*x1319*x1322))+((x1318*x1323))+((x1318*x1324))+(((-1.0)*x1320*x1325)));
evalcond[1]=((((-1.0)*cj5*r21*x1325))+((r21*x1318*x1322))+(((-1.0)*r22*sj4*x1326))+(((-1.0)*r20*x1321*x1326))+(((-1.0)*r20*sj5*x1325)));
evalcond[2]=((((-1.0)*cj5*r11*x1325))+(((-1.0)*r12*sj4*x1326))+(((-1.0)*r10*sj5*x1325))+((r11*x1318*x1322))+(((-1.0)*r10*x1321*x1326)));
evalcond[3]=((1.0)+(((-1.0)*x1323*x1325))+(((-1.0)*x1324*x1325))+(((-1.0)*r00*x1321*x1326))+((r01*x1318*x1322))+(((-1.0)*x1320*x1326)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1327=((0.76)*cj4);
IkReal x1328=(r11*sj5);
IkReal x1329=((0.76)*sj4);
IkReal x1330=((0.04)*cj4);
IkReal x1331=(r22*sj4);
IkReal x1332=((0.6)*cj4);
IkReal x1333=((2.28)*sj4);
IkReal x1334=((0.12)*cj4);
IkReal x1335=(cj5*r10);
IkReal x1336=(cj5*r20);
IkReal x1337=(cj4*r12);
IkReal x1338=((0.6)*sj4);
IkReal x1339=(r21*sj5);
IkReal x1340=((1.8)*sj4);
IkReal x1341=(cj4*r22);
IkReal x1342=(r12*sj4);
IkReal x1343=((0.12)*x1342);
IkReal x1344=((1.8)*x1337);
IkReal x1345=((0.12)*x1331);
IkReal x1346=((1.8)*x1341);
IkReal x1347=((2.28)*x1337);
IkReal x1348=(sj4*x1336);
IkReal x1349=(x1328*x1340);
IkReal x1350=(x1334*x1335);
IkReal x1351=(x1333*x1336);
IkReal x1352=(x1339*x1340);
IkReal x1353=(x1328*x1333);
IkReal x1354=(x1334*x1336);
IkReal x1355=((((12.0)*pz))+((x1336*x1340))+((x1333*x1335))+((x1334*x1339)));
IkReal x1356=((((12.0)*py))+((x1328*x1334))+(((2.28)*x1341))+((x1335*x1340))+((x1333*x1339)));
IkReal x1357=(x1349+x1343+x1344+x1351+x1350);
IkReal x1358=(x1345+x1346+x1347+x1353+x1352+x1354);
j1eval[0]=((6.4)+(IKabs(((-0.68)+x1358+(((-1.0)*x1355)))))+(IKabs(((-0.48)+x1357+(((-1.0)*x1356)))))+(IKabs(((-0.24)+(((-1.0)*x1335*x1338))+((x1329*x1336))+((r12*x1332))+(((-1.0)*r22*x1327))+(((0.04)*x1342))+(((-1.0)*x1328*x1330))+((x1328*x1338))+(((-1.0)*x1329*x1339))+((x1330*x1335))+(((-4.0)*py)))))+(IKabs(((-0.68)+((x1338*x1339))+(((-1.0)*x1330*x1339))+((r12*x1327))+((x1328*x1329))+(((-1.0)*x1329*x1335))+(((-1.0)*x1336*x1338))+((r22*x1332))+(((0.04)*x1331))+((x1330*x1336))+(((-4.0)*pz)))))+(IKabs(((-0.24)+x1357+(((-1.0)*x1356)))))+(IKabs(((0.68)+x1358+(((-1.0)*x1355))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1359=(cj4*r22);
IkReal x1360=((2.28)*sj4);
IkReal x1361=(r21*sj5);
IkReal x1362=((0.12)*cj4);
IkReal x1363=(r11*sj5);
IkReal x1364=(cj5*r10);
IkReal x1365=((1.8)*sj4);
IkReal x1366=(r12*sj4);
IkReal x1367=((0.04)*cj4);
IkReal x1368=(cj5*r20);
IkReal x1369=((0.76)*sj4);
IkReal x1370=(cj4*r12);
IkReal x1371=((0.6)*sj4);
IkReal x1372=((0.12)*x1366);
IkReal x1373=((1.8)*x1370);
IkReal x1374=((0.04)*x1366);
IkReal x1375=((0.6)*x1370);
IkReal x1376=(x1363*x1365);
IkReal x1377=(x1362*x1364);
IkReal x1378=(x1360*x1368);
IkReal x1379=(x1368*x1369);
IkReal x1380=(x1363*x1371);
IkReal x1381=(x1364*x1367);
IkReal x1382=((((12.0)*py))+((x1360*x1361))+((x1364*x1365))+(((2.28)*x1359))+((x1362*x1363)));
IkReal x1383=((((0.76)*x1359))+(((4.0)*py))+((x1361*x1369))+((x1363*x1367))+((x1364*x1371)));
IkReal x1384=(x1375+x1374+x1379+x1380+x1381);
IkReal x1385=(x1373+x1372+x1377+x1376+x1378);
op[0]=((-0.24)+(((-1.0)*x1383))+x1384);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x1382))+x1385);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x1382))+x1385);
op[5]=-1.36;
op[6]=((((-1.0)*x1383))+x1384);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1386=(r22*sj4);
IkReal x1387=(cj4*r22);
IkReal x1388=(cj4*r12);
IkReal x1389=(r21*sj5);
IkReal x1390=((0.12)*x1386);
IkReal x1391=((1.8)*x1387);
IkReal x1392=((2.28)*x1388);
IkReal x1393=((0.6)*x1387);
IkReal x1394=((0.76)*x1388);
IkReal x1395=((0.04)*x1386);
IkReal x1396=(r11*sj4*sj5);
IkReal x1397=(cj5*r20*sj4);
IkReal x1398=(cj4*cj5*r20);
IkReal x1399=(cj5*r10*sj4);
IkReal x1400=((1.8)*sj4*x1389);
IkReal x1401=((2.28)*x1396);
IkReal x1402=((0.12)*x1398);
IkReal x1403=((0.04)*x1398);
IkReal x1404=((0.6)*sj4*x1389);
IkReal x1405=((0.76)*x1396);
IkReal x1406=((((12.0)*pz))+(((2.28)*x1399))+(((0.12)*cj4*x1389))+(((1.8)*x1397)));
IkReal x1407=((((0.04)*cj4*x1389))+(((4.0)*pz))+(((0.76)*x1399))+(((0.6)*x1397)));
IkReal x1408=(x1395+x1394+x1393+x1403+x1405+x1404);
IkReal x1409=(x1392+x1391+x1390+x1402+x1401+x1400);
j1evalpoly[0]=((0.68)+(((htj1*htj1)*(((0.68)+(((-1.0)*x1406))+x1409))))+(((0.48)*(htj1*htj1*htj1)))+(((-1.0)*x1407))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.68)+(((-1.0)*x1407))+x1408))))+x1408+(((htj1*htj1*htj1*htj1)*(((-0.68)+(((-1.0)*x1406))+x1409))))+(((0.24)*htj1))+(((0.24)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1410=(cj1*sj4);
IkReal x1411=(cj5*r20);
IkReal x1412=(r11*sj5);
IkReal x1413=(sj1*sj4);
IkReal x1414=(cj4*r12);
IkReal x1415=(cj5*r10);
IkReal x1416=((1.0)*cj4*r22);
IkReal x1417=((1.0)*r21*sj5);
if( IKabs((((x1412*x1413))+(((-1.0)*cj1*x1416))+(((-1.0)*x1410*x1417))+((x1410*x1411))+(((-1.0)*x1413*x1415))+((sj1*x1414)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1413*x1417))+(((-1.0)*x1410*x1412))+((x1411*x1413))+((x1410*x1415))+(((-1.0)*sj1*x1416))+(((-1.0)*cj1*x1414)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1412*x1413))+(((-1.0)*cj1*x1416))+(((-1.0)*x1410*x1417))+((x1410*x1411))+(((-1.0)*x1413*x1415))+((sj1*x1414))))+IKsqr(((((-1.0)*x1413*x1417))+(((-1.0)*x1410*x1412))+((x1411*x1413))+((x1410*x1415))+(((-1.0)*sj1*x1416))+(((-1.0)*cj1*x1414))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((x1412*x1413))+(((-1.0)*cj1*x1416))+(((-1.0)*x1410*x1417))+((x1410*x1411))+(((-1.0)*x1413*x1415))+((sj1*x1414))), ((((-1.0)*x1413*x1417))+(((-1.0)*x1410*x1412))+((x1411*x1413))+((x1410*x1415))+(((-1.0)*sj1*x1416))+(((-1.0)*cj1*x1414))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1418=IKcos(j2);
IkReal x1419=IKsin(j2);
IkReal x1420=((0.15)*sj1);
IkReal x1421=(cj3*cj4);
IkReal x1422=(r21*sj5);
IkReal x1423=(r12*sj4);
IkReal x1424=((1.0)*cj3);
IkReal x1425=((1.0)*cj5);
IkReal x1426=(cj5*sj3);
IkReal x1427=(cj5*sj4);
IkReal x1428=((1.0)*cj4);
IkReal x1429=((0.19)*sj1);
IkReal x1430=(sj3*sj5);
IkReal x1431=((0.01)*cj4);
IkReal x1432=(r11*sj5);
IkReal x1433=((1.0)*sj4);
IkReal x1434=(r22*sj4);
IkReal x1435=(sj1*x1419);
IkReal x1436=(cj1*x1419);
IkReal x1437=((1.0)*x1418);
IkReal x1438=(cj1*x1418);
IkReal x1439=(cj1*x1437);
evalcond[0]=((((-1.0)*x1439))+(((-1.0)*r12*x1428))+((r10*x1427))+x1435+(((-1.0)*x1432*x1433)));
evalcond[1]=((((-1.0)*x1436))+(((-1.0)*x1422*x1433))+(((-1.0)*r22*x1428))+(((-1.0)*sj1*x1437))+((r20*x1427)));
evalcond[2]=(((r11*x1426))+(((-1.0)*r10*x1421*x1425))+((x1421*x1432))+(((-1.0)*x1423*x1424))+x1436+((sj1*x1418))+((r10*x1430)));
evalcond[3]=((((-1.0)*r20*x1421*x1425))+((r21*x1426))+((r20*x1430))+(((-1.0)*x1439))+x1435+(((-1.0)*x1424*x1434))+((x1421*x1422)));
evalcond[4]=((((0.17)*cj1))+(((0.03)*sj1))+(((-1.0)*x1422*x1431))+(((-0.15)*x1436))+(((-1.0)*x1418*x1420))+(((-1.0)*pz))+(((-0.19)*x1438))+((x1419*x1429))+((cj5*r20*x1431))+(((0.01)*x1434)));
evalcond[5]=((-0.03)+(((0.19)*x1436))+(((0.03)*cj1))+(((-0.15)*x1438))+(((0.01)*x1423))+(((-1.0)*x1431*x1432))+(((-1.0)*py))+((x1419*x1420))+((x1418*x1429))+((cj5*r10*x1431))+(((-0.17)*sj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1440=((1.0)*r11);
IkReal x1441=((1.0)*sj5);
CheckValue<IkReal> x1442=IKPowWithIntegerCheck(IKsign((((cj5*r20*sj4))+(((-1.0)*r21*sj4*x1441))+(((-1.0)*cj4*r22)))),-1);
if(!x1442.valid){
continue;
}
CheckValue<IkReal> x1443 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x1441))+(((-1.0)*cj5*x1440)))),IkReal(((((-1.0)*cj4*sj5*x1440))+((cj4*cj5*r10))+((r12*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1443.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1442.value)))+(x1443.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1444=IKsin(j3);
IkReal x1445=IKcos(j3);
IkReal x1446=(r02*sj4);
IkReal x1447=(cj4*cj5);
IkReal x1448=(cj4*sj5);
IkReal x1449=(cj5*r01);
IkReal x1450=(r00*sj5);
IkReal x1451=((1.0)*x1445);
IkReal x1452=((1.0)*x1444);
evalcond[0]=(((x1444*x1449))+(((-1.0)*r00*x1447*x1451))+((r01*x1445*x1448))+(((-1.0)*x1446*x1451))+((x1444*x1450)));
evalcond[1]=((((-1.0)*cj5*r21*x1451))+(((-1.0)*r22*sj4*x1452))+((r21*x1444*x1448))+(((-1.0)*r20*x1447*x1452))+(((-1.0)*r20*sj5*x1451)));
evalcond[2]=((((-1.0)*r10*sj5*x1451))+(((-1.0)*r12*sj4*x1452))+((r11*x1444*x1448))+(((-1.0)*cj5*r11*x1451))+(((-1.0)*r10*x1447*x1452)));
evalcond[3]=((1.0)+(((-1.0)*r00*x1447*x1452))+(((-1.0)*x1446*x1452))+((r01*x1444*x1448))+(((-1.0)*x1449*x1451))+(((-1.0)*x1450*x1451)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1453=((0.76)*cj4);
IkReal x1454=(r11*sj5);
IkReal x1455=((0.76)*sj4);
IkReal x1456=((0.04)*cj4);
IkReal x1457=(r22*sj4);
IkReal x1458=((0.6)*cj4);
IkReal x1459=((2.28)*sj4);
IkReal x1460=((0.12)*cj4);
IkReal x1461=(cj5*r10);
IkReal x1462=(cj5*r20);
IkReal x1463=(cj4*r12);
IkReal x1464=((0.6)*sj4);
IkReal x1465=(r21*sj5);
IkReal x1466=((1.8)*sj4);
IkReal x1467=(cj4*r22);
IkReal x1468=(r12*sj4);
IkReal x1469=((0.12)*x1468);
IkReal x1470=((1.8)*x1463);
IkReal x1471=((0.12)*x1457);
IkReal x1472=((1.8)*x1467);
IkReal x1473=((2.28)*x1463);
IkReal x1474=(sj4*x1462);
IkReal x1475=(x1454*x1466);
IkReal x1476=(x1460*x1461);
IkReal x1477=(x1459*x1462);
IkReal x1478=(x1465*x1466);
IkReal x1479=(x1454*x1459);
IkReal x1480=(x1460*x1462);
IkReal x1481=((((12.0)*pz))+((x1459*x1461))+((x1460*x1465))+((x1462*x1466)));
IkReal x1482=((((12.0)*py))+((x1459*x1465))+((x1461*x1466))+((x1454*x1460))+(((2.28)*x1467)));
IkReal x1483=(x1469+x1470+x1476+x1477+x1475);
IkReal x1484=(x1472+x1473+x1471+x1478+x1479+x1480);
j1eval[0]=((6.4)+(IKabs(((0.68)+(((-1.0)*x1481))+x1484)))+(IKabs(((-0.24)+(((-1.0)*x1482))+x1483)))+(IKabs(((-0.48)+(((-1.0)*x1482))+x1483)))+(IKabs(((-0.68)+(((-1.0)*x1481))+x1484)))+(IKabs(((-0.68)+((x1454*x1455))+(((-1.0)*x1456*x1465))+(((-1.0)*x1462*x1464))+((x1464*x1465))+((r12*x1453))+(((-1.0)*x1455*x1461))+(((0.04)*x1457))+((x1456*x1462))+((r22*x1458))+(((-4.0)*pz)))))+(IKabs(((-0.24)+(((-1.0)*r22*x1453))+(((-1.0)*x1454*x1456))+((x1455*x1462))+((r12*x1458))+((x1454*x1464))+(((-1.0)*x1455*x1465))+((x1456*x1461))+(((-1.0)*x1461*x1464))+(((-4.0)*py))+(((0.04)*x1468))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1485=(cj4*r22);
IkReal x1486=((2.28)*sj4);
IkReal x1487=(r21*sj5);
IkReal x1488=((0.12)*cj4);
IkReal x1489=(r11*sj5);
IkReal x1490=(cj5*r10);
IkReal x1491=((1.8)*sj4);
IkReal x1492=(r12*sj4);
IkReal x1493=((0.04)*cj4);
IkReal x1494=(cj5*r20);
IkReal x1495=((0.76)*sj4);
IkReal x1496=(cj4*r12);
IkReal x1497=((0.6)*sj4);
IkReal x1498=((0.12)*x1492);
IkReal x1499=((1.8)*x1496);
IkReal x1500=((0.04)*x1492);
IkReal x1501=((0.6)*x1496);
IkReal x1502=(x1489*x1491);
IkReal x1503=(x1488*x1490);
IkReal x1504=(x1486*x1494);
IkReal x1505=(x1494*x1495);
IkReal x1506=(x1489*x1497);
IkReal x1507=(x1490*x1493);
IkReal x1508=((((12.0)*py))+(((2.28)*x1485))+((x1486*x1487))+((x1488*x1489))+((x1490*x1491)));
IkReal x1509=(((x1489*x1493))+(((4.0)*py))+((x1487*x1495))+(((0.76)*x1485))+((x1490*x1497)));
IkReal x1510=(x1500+x1501+x1506+x1507+x1505);
IkReal x1511=(x1502+x1503+x1504+x1498+x1499);
op[0]=((-0.24)+(((-1.0)*x1509))+x1510);
op[1]=-1.36;
op[2]=((-0.48)+(((-1.0)*x1508))+x1511);
op[3]=-2.72;
op[4]=((-0.24)+(((-1.0)*x1508))+x1511);
op[5]=-1.36;
op[6]=((((-1.0)*x1509))+x1510);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1512=(r22*sj4);
IkReal x1513=(cj4*r22);
IkReal x1514=(cj4*r12);
IkReal x1515=(r21*sj5);
IkReal x1516=((0.12)*x1512);
IkReal x1517=((1.8)*x1513);
IkReal x1518=((2.28)*x1514);
IkReal x1519=((0.6)*x1513);
IkReal x1520=((0.76)*x1514);
IkReal x1521=((0.04)*x1512);
IkReal x1522=(r11*sj4*sj5);
IkReal x1523=(cj5*r20*sj4);
IkReal x1524=(cj4*cj5*r20);
IkReal x1525=(cj5*r10*sj4);
IkReal x1526=((1.8)*sj4*x1515);
IkReal x1527=((2.28)*x1522);
IkReal x1528=((0.12)*x1524);
IkReal x1529=((0.04)*x1524);
IkReal x1530=((0.6)*sj4*x1515);
IkReal x1531=((0.76)*x1522);
IkReal x1532=((((12.0)*pz))+(((2.28)*x1525))+(((0.12)*cj4*x1515))+(((1.8)*x1523)));
IkReal x1533=((((0.04)*cj4*x1515))+(((4.0)*pz))+(((0.76)*x1525))+(((0.6)*x1523)));
IkReal x1534=(x1520+x1521+x1529+x1531+x1530+x1519);
IkReal x1535=(x1526+x1527+x1528+x1518+x1517+x1516);
j1evalpoly[0]=((0.68)+(((htj1*htj1)*(((0.68)+(((-1.0)*x1532))+x1535))))+(((0.48)*(htj1*htj1*htj1)))+(((-1.0)*x1533))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.68)+(((-1.0)*x1533))+x1534))))+(((htj1*htj1*htj1*htj1)*(((-0.68)+(((-1.0)*x1532))+x1535))))+x1534+(((0.24)*htj1))+(((0.24)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1536=(cj1*sj4);
IkReal x1537=(cj5*r20);
IkReal x1538=(r11*sj5);
IkReal x1539=(sj1*sj4);
IkReal x1540=(cj4*r12);
IkReal x1541=(cj5*r10);
IkReal x1542=((1.0)*cj4*r22);
IkReal x1543=((1.0)*r21*sj5);
if( IKabs(((((-1.0)*x1539*x1541))+((x1538*x1539))+((x1536*x1537))+(((-1.0)*cj1*x1542))+((sj1*x1540))+(((-1.0)*x1536*x1543)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1536*x1541))+((x1537*x1539))+(((-1.0)*x1539*x1543))+(((-1.0)*cj1*x1540))+(((-1.0)*x1536*x1538))+(((-1.0)*sj1*x1542)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1539*x1541))+((x1538*x1539))+((x1536*x1537))+(((-1.0)*cj1*x1542))+((sj1*x1540))+(((-1.0)*x1536*x1543))))+IKsqr((((x1536*x1541))+((x1537*x1539))+(((-1.0)*x1539*x1543))+(((-1.0)*cj1*x1540))+(((-1.0)*x1536*x1538))+(((-1.0)*sj1*x1542))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1539*x1541))+((x1538*x1539))+((x1536*x1537))+(((-1.0)*cj1*x1542))+((sj1*x1540))+(((-1.0)*x1536*x1543))), (((x1536*x1541))+((x1537*x1539))+(((-1.0)*x1539*x1543))+(((-1.0)*cj1*x1540))+(((-1.0)*x1536*x1538))+(((-1.0)*sj1*x1542))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1544=IKcos(j2);
IkReal x1545=IKsin(j2);
IkReal x1546=((0.15)*sj1);
IkReal x1547=(cj3*cj4);
IkReal x1548=(r21*sj5);
IkReal x1549=(r12*sj4);
IkReal x1550=((1.0)*cj3);
IkReal x1551=((1.0)*cj5);
IkReal x1552=(cj5*sj3);
IkReal x1553=(cj5*sj4);
IkReal x1554=((1.0)*cj4);
IkReal x1555=((0.19)*sj1);
IkReal x1556=(sj3*sj5);
IkReal x1557=((0.01)*cj4);
IkReal x1558=(r11*sj5);
IkReal x1559=((1.0)*sj4);
IkReal x1560=(r22*sj4);
IkReal x1561=(sj1*x1545);
IkReal x1562=(cj1*x1545);
IkReal x1563=((1.0)*x1544);
IkReal x1564=(cj1*x1544);
IkReal x1565=(cj1*x1563);
evalcond[0]=((((-1.0)*x1558*x1559))+x1561+(((-1.0)*r12*x1554))+(((-1.0)*x1565))+((r10*x1553)));
evalcond[1]=((((-1.0)*sj1*x1563))+(((-1.0)*r22*x1554))+(((-1.0)*x1548*x1559))+(((-1.0)*x1562))+((r20*x1553)));
evalcond[2]=(((x1547*x1558))+(((-1.0)*x1549*x1550))+((r11*x1552))+(((-1.0)*r10*x1547*x1551))+x1562+((sj1*x1544))+((r10*x1556)));
evalcond[3]=(((x1547*x1548))+(((-1.0)*r20*x1547*x1551))+(((-1.0)*x1550*x1560))+x1561+((r21*x1552))+(((-1.0)*x1565))+((r20*x1556)));
evalcond[4]=((((0.17)*cj1))+(((-0.15)*x1562))+((cj5*r20*x1557))+(((0.03)*sj1))+(((-1.0)*x1548*x1557))+(((0.01)*x1560))+(((-1.0)*pz))+(((-0.19)*x1564))+(((-1.0)*x1544*x1546))+((x1545*x1555)));
evalcond[5]=((-0.03)+(((0.19)*x1562))+(((-0.15)*x1564))+((cj5*r10*x1557))+((x1544*x1555))+(((0.03)*cj1))+(((-1.0)*py))+(((0.01)*x1549))+(((-1.0)*x1557*x1558))+(((-0.17)*sj1))+((x1545*x1546)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1566=((1.0)*r21);
CheckValue<IkReal> x1567=IKPowWithIntegerCheck(IKsign((((r11*sj4*sj5))+((cj4*r12))+(((-1.0)*cj5*r10*sj4)))),-1);
if(!x1567.valid){
continue;
}
CheckValue<IkReal> x1568 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*x1566))+(((-1.0)*r20*sj5)))),IkReal(((((-1.0)*cj4*sj5*x1566))+((r22*sj4))+((cj4*cj5*r20)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1568.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1567.value)))+(x1568.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1569=IKsin(j3);
IkReal x1570=IKcos(j3);
IkReal x1571=(r02*sj4);
IkReal x1572=(cj4*cj5);
IkReal x1573=(cj4*sj5);
IkReal x1574=(cj5*r01);
IkReal x1575=(r00*sj5);
IkReal x1576=((1.0)*x1570);
IkReal x1577=((1.0)*x1569);
evalcond[0]=((((-1.0)*x1571*x1576))+((x1569*x1574))+((x1569*x1575))+(((-1.0)*r00*x1572*x1576))+((r01*x1570*x1573)));
evalcond[1]=(((r21*x1569*x1573))+(((-1.0)*r20*x1572*x1577))+(((-1.0)*r22*sj4*x1577))+(((-1.0)*cj5*r21*x1576))+(((-1.0)*r20*sj5*x1576)));
evalcond[2]=(((r11*x1569*x1573))+(((-1.0)*cj5*r11*x1576))+(((-1.0)*r12*sj4*x1577))+(((-1.0)*r10*sj5*x1576))+(((-1.0)*r10*x1572*x1577)));
evalcond[3]=((1.0)+((r01*x1569*x1573))+(((-1.0)*x1571*x1577))+(((-1.0)*x1575*x1576))+(((-1.0)*r00*x1572*x1577))+(((-1.0)*x1574*x1576)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1578=((0.76)*cj4);
IkReal x1579=(r11*sj5);
IkReal x1580=((0.76)*sj4);
IkReal x1581=((0.04)*cj4);
IkReal x1582=(r22*sj4);
IkReal x1583=((0.6)*cj4);
IkReal x1584=((2.28)*sj4);
IkReal x1585=((0.12)*cj4);
IkReal x1586=(cj5*r10);
IkReal x1587=(cj5*r20);
IkReal x1588=(cj4*r12);
IkReal x1589=((0.6)*sj4);
IkReal x1590=(r21*sj5);
IkReal x1591=((1.8)*sj4);
IkReal x1592=(cj4*r22);
IkReal x1593=(r12*sj4);
IkReal x1594=((0.12)*x1593);
IkReal x1595=((1.8)*x1588);
IkReal x1596=((0.12)*x1582);
IkReal x1597=((1.8)*x1592);
IkReal x1598=((2.28)*x1588);
IkReal x1599=(sj4*x1587);
IkReal x1600=(x1579*x1591);
IkReal x1601=(x1585*x1586);
IkReal x1602=(x1584*x1587);
IkReal x1603=(x1590*x1591);
IkReal x1604=(x1579*x1584);
IkReal x1605=(x1585*x1587);
IkReal x1606=(((x1587*x1591))+(((12.0)*pz))+((x1584*x1586))+((x1585*x1590)));
IkReal x1607=(((x1586*x1591))+((x1584*x1590))+(((12.0)*py))+(((2.28)*x1592))+((x1579*x1585)));
IkReal x1608=(x1601+x1600+x1602+x1595+x1594);
IkReal x1609=(x1603+x1605+x1604+x1597+x1596+x1598);
j1eval[0]=((6.4)+(IKabs(((-0.24)+(((-1.0)*x1580*x1590))+(((0.04)*x1593))+((r12*x1583))+(((-1.0)*r22*x1578))+((x1580*x1587))+(((-1.0)*x1579*x1581))+((x1579*x1589))+(((-1.0)*x1586*x1589))+(((-4.0)*py))+((x1581*x1586)))))+(IKabs(((0.68)+(((-1.0)*x1606))+x1609)))+(IKabs(((-0.48)+(((-1.0)*x1607))+x1608)))+(IKabs(((-0.68)+(((-1.0)*x1606))+x1609)))+(IKabs(((-0.24)+(((-1.0)*x1607))+x1608)))+(IKabs(((-0.68)+(((-1.0)*x1580*x1586))+(((0.04)*x1582))+((x1589*x1590))+((r12*x1578))+((r22*x1583))+(((-1.0)*x1581*x1590))+((x1579*x1580))+(((-4.0)*pz))+(((-1.0)*x1587*x1589))+((x1581*x1587))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1610=(cj4*r22);
IkReal x1611=((2.28)*sj4);
IkReal x1612=(r21*sj5);
IkReal x1613=((0.12)*cj4);
IkReal x1614=(r11*sj5);
IkReal x1615=(cj5*r10);
IkReal x1616=((1.8)*sj4);
IkReal x1617=(r12*sj4);
IkReal x1618=((0.04)*cj4);
IkReal x1619=(cj5*r20);
IkReal x1620=((0.76)*sj4);
IkReal x1621=(cj4*r12);
IkReal x1622=((0.6)*sj4);
IkReal x1623=((0.12)*x1617);
IkReal x1624=((1.8)*x1621);
IkReal x1625=((0.04)*x1617);
IkReal x1626=((0.6)*x1621);
IkReal x1627=(x1614*x1616);
IkReal x1628=(x1613*x1615);
IkReal x1629=(x1611*x1619);
IkReal x1630=(x1619*x1620);
IkReal x1631=(x1614*x1622);
IkReal x1632=(x1615*x1618);
IkReal x1633=((((2.28)*x1610))+(((12.0)*py))+((x1615*x1616))+((x1611*x1612))+((x1613*x1614)));
IkReal x1634=((((4.0)*py))+((x1614*x1618))+((x1615*x1622))+((x1612*x1620))+(((0.76)*x1610)));
IkReal x1635=(x1626+x1625+x1630+x1631+x1632);
IkReal x1636=(x1623+x1627+x1624+x1629+x1628);
op[0]=((-0.24)+x1635+(((-1.0)*x1634)));
op[1]=-1.36;
op[2]=((-0.48)+x1636+(((-1.0)*x1633)));
op[3]=-2.72;
op[4]=((-0.24)+x1636+(((-1.0)*x1633)));
op[5]=-1.36;
op[6]=(x1635+(((-1.0)*x1634)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1637=(r22*sj4);
IkReal x1638=(cj4*r22);
IkReal x1639=(cj4*r12);
IkReal x1640=(r21*sj5);
IkReal x1641=((0.12)*x1637);
IkReal x1642=((1.8)*x1638);
IkReal x1643=((2.28)*x1639);
IkReal x1644=((0.6)*x1638);
IkReal x1645=((0.76)*x1639);
IkReal x1646=((0.04)*x1637);
IkReal x1647=(r11*sj4*sj5);
IkReal x1648=(cj5*r20*sj4);
IkReal x1649=(cj4*cj5*r20);
IkReal x1650=(cj5*r10*sj4);
IkReal x1651=((1.8)*sj4*x1640);
IkReal x1652=((2.28)*x1647);
IkReal x1653=((0.12)*x1649);
IkReal x1654=((0.04)*x1649);
IkReal x1655=((0.6)*sj4*x1640);
IkReal x1656=((0.76)*x1647);
IkReal x1657=((((12.0)*pz))+(((1.8)*x1648))+(((0.12)*cj4*x1640))+(((2.28)*x1650)));
IkReal x1658=((((0.04)*cj4*x1640))+(((4.0)*pz))+(((0.6)*x1648))+(((0.76)*x1650)));
IkReal x1659=(x1656+x1654+x1655+x1645+x1644+x1646);
IkReal x1660=(x1652+x1653+x1651+x1641+x1643+x1642);
j1evalpoly[0]=((0.68)+(((htj1*htj1*htj1*htj1)*(((-0.68)+x1660+(((-1.0)*x1657))))))+(((0.48)*(htj1*htj1*htj1)))+x1659+(((-1.0)*x1658))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-0.68)+x1659+(((-1.0)*x1658))))))+(((htj1*htj1)*(((0.68)+x1660+(((-1.0)*x1657))))))+(((0.24)*htj1))+(((0.24)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1661=(cj1*sj4);
IkReal x1662=(cj5*r20);
IkReal x1663=(r11*sj5);
IkReal x1664=(sj1*sj4);
IkReal x1665=(cj4*r12);
IkReal x1666=(cj5*r10);
IkReal x1667=((1.0)*cj4*r22);
IkReal x1668=((1.0)*r21*sj5);
if( IKabs((((sj1*x1665))+(((-1.0)*x1661*x1668))+(((-1.0)*cj1*x1667))+(((-1.0)*x1664*x1666))+((x1661*x1662))+((x1663*x1664)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x1667))+((x1662*x1664))+((x1661*x1666))+(((-1.0)*cj1*x1665))+(((-1.0)*x1661*x1663))+(((-1.0)*x1664*x1668)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj1*x1665))+(((-1.0)*x1661*x1668))+(((-1.0)*cj1*x1667))+(((-1.0)*x1664*x1666))+((x1661*x1662))+((x1663*x1664))))+IKsqr(((((-1.0)*sj1*x1667))+((x1662*x1664))+((x1661*x1666))+(((-1.0)*cj1*x1665))+(((-1.0)*x1661*x1663))+(((-1.0)*x1664*x1668))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((sj1*x1665))+(((-1.0)*x1661*x1668))+(((-1.0)*cj1*x1667))+(((-1.0)*x1664*x1666))+((x1661*x1662))+((x1663*x1664))), ((((-1.0)*sj1*x1667))+((x1662*x1664))+((x1661*x1666))+(((-1.0)*cj1*x1665))+(((-1.0)*x1661*x1663))+(((-1.0)*x1664*x1668))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1669=IKcos(j2);
IkReal x1670=IKsin(j2);
IkReal x1671=((0.15)*sj1);
IkReal x1672=(cj3*cj4);
IkReal x1673=(r21*sj5);
IkReal x1674=(r12*sj4);
IkReal x1675=((1.0)*cj3);
IkReal x1676=((1.0)*cj5);
IkReal x1677=(cj5*sj3);
IkReal x1678=(cj5*sj4);
IkReal x1679=((1.0)*cj4);
IkReal x1680=((0.19)*sj1);
IkReal x1681=(sj3*sj5);
IkReal x1682=((0.01)*cj4);
IkReal x1683=(r11*sj5);
IkReal x1684=((1.0)*sj4);
IkReal x1685=(r22*sj4);
IkReal x1686=(sj1*x1670);
IkReal x1687=(cj1*x1670);
IkReal x1688=((1.0)*x1669);
IkReal x1689=(cj1*x1669);
IkReal x1690=(cj1*x1688);
evalcond[0]=((((-1.0)*x1690))+x1686+(((-1.0)*x1683*x1684))+(((-1.0)*r12*x1679))+((r10*x1678)));
evalcond[1]=((((-1.0)*x1687))+(((-1.0)*x1673*x1684))+((r20*x1678))+(((-1.0)*sj1*x1688))+(((-1.0)*r22*x1679)));
evalcond[2]=(((sj1*x1669))+((x1672*x1683))+((r10*x1681))+x1687+(((-1.0)*r10*x1672*x1676))+(((-1.0)*x1674*x1675))+((r11*x1677)));
evalcond[3]=(((r21*x1677))+(((-1.0)*x1690))+(((-1.0)*x1675*x1685))+x1686+(((-1.0)*r20*x1672*x1676))+((x1672*x1673))+((r20*x1681)));
evalcond[4]=((((0.17)*cj1))+(((-0.19)*x1689))+(((0.03)*sj1))+((x1670*x1680))+(((-1.0)*x1669*x1671))+(((-1.0)*x1673*x1682))+(((0.01)*x1685))+((cj5*r20*x1682))+(((-1.0)*pz))+(((-0.15)*x1687)));
evalcond[5]=((-0.03)+((cj5*r10*x1682))+((x1669*x1680))+(((-1.0)*x1682*x1683))+(((0.03)*cj1))+(((-1.0)*py))+(((0.19)*x1687))+(((-0.15)*x1689))+(((0.01)*x1674))+(((-0.17)*sj1))+((x1670*x1671)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j2, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1691=((1.0)*sj0);
IkReal x1692=(cj4*cj5);
IkReal x1693=(cj0*r00);
IkReal x1694=((1.0)*cj5);
IkReal x1695=(cj4*sj5);
IkReal x1696=(cj0*r01);
CheckValue<IkReal> x1697=IKPowWithIntegerCheck(IKsign((((r21*sj4*sj5))+((cj4*r22))+(((-1.0)*r20*sj4*x1694)))),-1);
if(!x1697.valid){
continue;
}
CheckValue<IkReal> x1698 = IKatan2WithCheck(IkReal(((((-1.0)*cj5*r11*x1691))+(((-1.0)*x1694*x1696))+(((-1.0)*r10*sj5*x1691))+(((-1.0)*sj5*x1693)))),IkReal(((((-1.0)*x1695*x1696))+((r12*sj0*sj4))+((x1692*x1693))+(((-1.0)*r11*x1691*x1695))+((cj0*r02*sj4))+((r10*sj0*x1692)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1698.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1697.value)))+(x1698.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1699=IKsin(j3);
IkReal x1700=IKcos(j3);
IkReal x1701=((1.0)*cj5);
IkReal x1702=(cj4*x1699);
IkReal x1703=((1.0)*sj5*x1700);
IkReal x1704=((1.0)*sj4*x1699);
evalcond[0]=((((-1.0)*r20*x1701*x1702))+(((-1.0)*r20*x1703))+(((-1.0)*r21*x1700*x1701))+((r21*sj5*x1702))+(((-1.0)*r22*x1704)));
evalcond[1]=((((-1.0)*r11*x1700*x1701))+cj0+(((-1.0)*r10*x1703))+((r11*sj5*x1702))+(((-1.0)*r10*x1701*x1702))+(((-1.0)*r12*x1704)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r00*x1701*x1702))+((r01*sj5*x1702))+(((-1.0)*r02*x1704))+(((-1.0)*r00*x1703))+(((-1.0)*r01*x1700*x1701)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1705=((0.68)*cj0);
IkReal x1706=((0.68)*sj0);
IkReal x1707=(cj0*cj4);
IkReal x1708=((0.6)*r22);
IkReal x1709=(r21*sj5);
IkReal x1710=(cj4*sj0);
IkReal x1711=(sj0*sj4);
IkReal x1712=((0.12)*r22);
IkReal x1713=(cj5*sj4);
IkReal x1714=((2.28)*cj4);
IkReal x1715=(cj0*sj4);
IkReal x1716=((0.6)*r20);
IkReal x1717=((0.76)*cj4);
IkReal x1718=((1.8)*r22);
IkReal x1719=(cj5*r20);
IkReal x1720=((0.04)*r22);
IkReal x1721=(pz*sj0);
IkReal x1722=(cj0*pz);
IkReal x1723=((12.0)*x1722);
IkReal x1724=(r02*x1714);
IkReal x1725=((12.0)*x1721);
IkReal x1726=(r12*x1714);
IkReal x1727=((0.76)*sj4*sj5);
IkReal x1728=((0.12)*x1719);
IkReal x1729=((2.28)*sj4*sj5);
IkReal x1730=(r01*x1729);
IkReal x1731=((2.28)*r00*x1713);
IkReal x1732=(x1712*x1715);
IkReal x1733=(x1707*x1718);
IkReal x1734=(r11*x1729);
IkReal x1735=(x1711*x1712);
IkReal x1736=((2.28)*r10*x1713);
IkReal x1737=(x1710*x1718);
IkReal x1738=((1.8)*cj0*r20*x1713);
IkReal x1739=((0.12)*x1707*x1709);
IkReal x1740=(x1707*x1728);
IkReal x1741=((1.8)*x1709*x1715);
IkReal x1742=((0.12)*x1709*x1710);
IkReal x1743=((1.8)*x1711*x1719);
IkReal x1744=((1.8)*x1709*x1711);
IkReal x1745=(x1710*x1728);
IkReal x1746=(x1726+x1725+x1734+x1742+x1743);
IkReal x1747=(x1724+x1723+x1739+x1738+x1730);
IkReal x1748=(x1735+x1737+x1736+x1744+x1745);
IkReal x1749=(x1731+x1733+x1732+x1740+x1741);
j1eval[0]=((((1.04166666666667)*(IKabs((x1746+(((-1.0)*x1706))+(((-1.0)*x1748)))))))+(IKabs(cj0))+(IKabs(sj0))+(((1.04166666666667)*(IKabs((((r02*x1717))+((r01*x1727))+(((-1.0)*x1715*x1720))+(((4.0)*x1722))+x1705+(((-1.0)*x1707*x1708))+(((0.04)*x1707*x1709))+(((-0.04)*x1707*x1719))+(((-0.76)*r00*x1713))+((cj0*x1713*x1716))+(((-0.6)*x1709*x1715)))))))+(((1.04166666666667)*(IKabs(((((4.0)*x1721))+(((-0.76)*r10*x1713))+x1706+((r12*x1717))+(((-1.0)*x1708*x1710))+((r11*x1727))+(((0.04)*x1709*x1710))+(((-0.04)*x1710*x1719))+((cj5*x1711*x1716))+(((-1.0)*x1711*x1720))+(((-0.6)*x1709*x1711)))))))+(((1.04166666666667)*(IKabs((x1705+x1747+(((-1.0)*x1749)))))))+(((1.04166666666667)*(IKabs((x1706+x1746+(((-1.0)*x1748)))))))+(((1.04166666666667)*(IKabs((x1747+(((-1.0)*x1705))+(((-1.0)*x1749))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1750=((0.68)*cj0);
IkReal x1751=((0.6)*cj0);
IkReal x1752=(cj4*r22);
IkReal x1753=(cj5*r20);
IkReal x1754=(sj4*sj5);
IkReal x1755=(r21*sj5);
IkReal x1756=(cj4*r02);
IkReal x1757=((1.8)*cj0);
IkReal x1758=(cj0*pz);
IkReal x1759=((12.0)*x1758);
IkReal x1760=((2.28)*x1756);
IkReal x1761=((-0.24)*cj0);
IkReal x1762=((4.0)*x1758);
IkReal x1763=((0.76)*x1756);
IkReal x1764=((0.12)*cj0*cj4);
IkReal x1765=(cj5*r00*sj4);
IkReal x1766=(cj0*r22*sj4);
IkReal x1767=((0.04)*cj0*cj4);
IkReal x1768=((2.28)*r01*x1754);
IkReal x1769=((2.28)*x1765);
IkReal x1770=((0.12)*x1766);
IkReal x1771=(x1752*x1757);
IkReal x1772=((0.76)*r01*x1754);
IkReal x1773=(x1751*x1752);
IkReal x1774=((0.76)*x1765);
IkReal x1775=((0.04)*x1766);
IkReal x1776=(sj4*x1753*x1757);
IkReal x1777=(x1755*x1764);
IkReal x1778=(x1753*x1764);
IkReal x1779=(r21*x1754*x1757);
IkReal x1780=(x1755*x1767);
IkReal x1781=(sj4*x1751*x1753);
IkReal x1782=(r21*x1751*x1754);
IkReal x1783=(x1753*x1767);
IkReal x1784=(x1780+x1781+x1762+x1763+x1772);
IkReal x1785=(x1768+x1760+x1777+x1776+x1759);
IkReal x1786=(x1769+x1771+x1770+x1779+x1778);
IkReal x1787=(x1782+x1783+x1775+x1774+x1773);
op[0]=((((-1.0)*x1787))+x1784+x1750);
op[1]=x1761;
op[2]=((((-1.0)*x1786))+x1785+x1750);
op[3]=((-0.48)*cj0);
op[4]=((((-1.0)*x1786))+x1785+(((-1.0)*x1750)));
op[5]=x1761;
op[6]=((((-1.0)*x1787))+x1784+(((-1.0)*x1750)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1788=((0.68)*sj0);
IkReal x1789=((0.12)*sj0);
IkReal x1790=(cj5*r20);
IkReal x1791=(r22*sj4);
IkReal x1792=(r21*sj5);
IkReal x1793=((0.24)*sj0);
IkReal x1794=(cj4*r12);
IkReal x1795=((0.6)*sj0);
IkReal x1796=(cj4*r22);
IkReal x1797=((0.04)*sj0);
IkReal x1798=(pz*sj0);
IkReal x1799=((12.0)*x1798);
IkReal x1800=((2.28)*x1794);
IkReal x1801=((4.0)*x1798);
IkReal x1802=((0.76)*x1794);
IkReal x1803=(r11*sj4*sj5);
IkReal x1804=((1.8)*sj0*sj4);
IkReal x1805=(cj5*r10*sj4);
IkReal x1806=((2.28)*x1803);
IkReal x1807=(x1789*x1791);
IkReal x1808=((2.28)*x1805);
IkReal x1809=((1.8)*sj0*x1796);
IkReal x1810=((0.76)*x1803);
IkReal x1811=(x1791*x1797);
IkReal x1812=((0.76)*x1805);
IkReal x1813=(x1795*x1796);
IkReal x1814=(cj4*x1789*x1792);
IkReal x1815=(x1790*x1804);
IkReal x1816=(x1792*x1804);
IkReal x1817=(cj4*x1789*x1790);
IkReal x1818=(cj4*x1792*x1797);
IkReal x1819=(sj4*x1790*x1795);
IkReal x1820=(sj4*x1792*x1795);
IkReal x1821=(cj4*x1790*x1797);
IkReal x1822=(x1799+x1814+x1815+x1806+x1800);
IkReal x1823=(x1810+x1818+x1819+x1802+x1801);
IkReal x1824=(x1816+x1817+x1807+x1809+x1808);
IkReal x1825=(x1821+x1820+x1811+x1812+x1813);
j1evalpoly[0]=((((-1.0)*x1825))+(((-0.48)*sj0*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1825))+x1788+x1823))))+(((-1.0)*x1788))+(((htj1*htj1*htj1*htj1)*(((((-1.0)*x1824))+x1788+x1822))))+(((-1.0)*x1793*(htj1*htj1*htj1*htj1*htj1)))+x1823+(((-1.0)*htj1*x1793))+(((htj1*htj1)*(((((-1.0)*x1824))+(((-1.0)*x1788))+x1822)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1826=((1.0)*cj1);
IkReal x1827=(cj4*r22);
IkReal x1828=(r21*sj5);
IkReal x1829=(cj1*r20);
IkReal x1830=(sj3*sj5);
IkReal x1831=(cj3*sj1);
IkReal x1832=(r22*sj4);
IkReal x1833=((1.0)*sj1);
IkReal x1834=(cj3*cj4);
IkReal x1835=(cj5*r20);
IkReal x1836=(cj5*r21*sj3);
if( IKabs((((cj5*sj4*x1829))+(((-1.0)*x1833*x1836))+(((-1.0)*x1826*x1827))+((x1831*x1832))+(((-1.0)*sj4*x1826*x1828))+((cj4*x1831*x1835))+(((-1.0)*cj4*x1828*x1831))+(((-1.0)*r20*x1830*x1833)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj3*x1826*x1832))+(((-1.0)*sj4*x1828*x1833))+((x1829*x1830))+(((-1.0)*x1826*x1834*x1835))+(((-1.0)*x1827*x1833))+((cj1*x1828*x1834))+((sj1*sj4*x1835))+((cj1*x1836)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj5*sj4*x1829))+(((-1.0)*x1833*x1836))+(((-1.0)*x1826*x1827))+((x1831*x1832))+(((-1.0)*sj4*x1826*x1828))+((cj4*x1831*x1835))+(((-1.0)*cj4*x1828*x1831))+(((-1.0)*r20*x1830*x1833))))+IKsqr(((((-1.0)*cj3*x1826*x1832))+(((-1.0)*sj4*x1828*x1833))+((x1829*x1830))+(((-1.0)*x1826*x1834*x1835))+(((-1.0)*x1827*x1833))+((cj1*x1828*x1834))+((sj1*sj4*x1835))+((cj1*x1836))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj5*sj4*x1829))+(((-1.0)*x1833*x1836))+(((-1.0)*x1826*x1827))+((x1831*x1832))+(((-1.0)*sj4*x1826*x1828))+((cj4*x1831*x1835))+(((-1.0)*cj4*x1828*x1831))+(((-1.0)*r20*x1830*x1833))), ((((-1.0)*cj3*x1826*x1832))+(((-1.0)*sj4*x1828*x1833))+((x1829*x1830))+(((-1.0)*x1826*x1834*x1835))+(((-1.0)*x1827*x1833))+((cj1*x1828*x1834))+((sj1*sj4*x1835))+((cj1*x1836))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1837=IKcos(j2);
IkReal x1838=IKsin(j2);
IkReal x1839=(cj1*sj0);
IkReal x1840=((1.0)*cj3);
IkReal x1841=(r02*sj4);
IkReal x1842=(cj4*cj5);
IkReal x1843=(r12*sj4);
IkReal x1844=(r01*sj5);
IkReal x1845=((1.0)*sj4);
IkReal x1846=(cj0*cj1);
IkReal x1847=(cj5*sj3);
IkReal x1848=(sj0*sj1);
IkReal x1849=(sj3*sj5);
IkReal x1850=(cj5*sj4);
IkReal x1851=((1.0)*cj4);
IkReal x1852=(cj0*sj1);
IkReal x1853=((0.01)*cj4);
IkReal x1854=(r21*sj5);
IkReal x1855=(r11*sj5);
IkReal x1856=(r22*sj4);
IkReal x1857=((0.15)*x1837);
IkReal x1858=(cj3*cj4*sj5);
IkReal x1859=((1.0)*x1837);
IkReal x1860=(sj1*x1838);
IkReal x1861=((1.0)*x1838);
IkReal x1862=((0.19)*x1837);
IkReal x1863=((0.19)*x1838);
evalcond[0]=((((-1.0)*x1845*x1854))+(((-1.0)*r22*x1851))+(((-1.0)*cj1*x1861))+(((-1.0)*sj1*x1859))+((r20*x1850)));
evalcond[1]=(((x1837*x1846))+((r00*x1850))+(((-1.0)*x1852*x1861))+(((-1.0)*r02*x1851))+(((-1.0)*x1844*x1845)));
evalcond[2]=((((-1.0)*x1845*x1855))+((r10*x1850))+(((-1.0)*x1848*x1861))+((x1837*x1839))+(((-1.0)*r12*x1851)));
evalcond[3]=((((-1.0)*x1840*x1856))+(((-1.0)*r20*x1840*x1842))+((r20*x1849))+x1860+((r21*x1847))+((cj3*cj4*x1854))+(((-1.0)*cj1*x1859)));
evalcond[4]=((((-1.0)*x1852*x1859))+((r00*x1849))+((r01*x1847))+(((-1.0)*x1846*x1861))+(((-1.0)*x1840*x1841))+(((-1.0)*r00*x1840*x1842))+((cj3*cj4*x1844)));
evalcond[5]=((((-1.0)*x1848*x1859))+(((-1.0)*x1839*x1861))+((r10*x1849))+(((-1.0)*x1840*x1843))+((cj3*cj4*x1855))+(((-1.0)*r10*x1840*x1842))+((r11*x1847)));
evalcond[6]=((((0.17)*cj1))+(((0.03)*sj1))+(((-0.15)*cj1*x1838))+(((0.01)*x1856))+(((-1.0)*pz))+(((0.19)*x1860))+(((-1.0)*cj1*x1862))+(((-1.0)*sj1*x1857))+(((0.01)*r20*x1842))+(((-1.0)*x1853*x1854)));
evalcond[7]=(((x1846*x1857))+(((0.01)*x1841))+(((0.03)*cj0))+(((0.01)*r00*x1842))+(((0.17)*x1852))+(((-0.15)*x1838*x1852))+(((-1.0)*x1852*x1862))+(((-0.03)*x1846))+(((-1.0)*px))+(((-1.0)*x1846*x1863))+(((-1.0)*x1844*x1853)));
evalcond[8]=((((-0.03)*x1839))+(((0.17)*x1848))+(((0.03)*sj0))+(((0.01)*x1843))+(((-1.0)*x1839*x1863))+(((-1.0)*py))+(((-1.0)*x1848*x1862))+((x1839*x1857))+(((-0.15)*x1838*x1848))+(((-1.0)*x1853*x1855))+(((0.01)*r10*x1842)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1864=((1.0)*sj0);
CheckValue<IkReal> x1865=IKPowWithIntegerCheck(IKsign((((cj5*r10*sj4))+(((-1.0)*r11*sj4*sj5))+(((-1.0)*cj4*r12)))),-1);
if(!x1865.valid){
continue;
}
CheckValue<IkReal> x1866 = IKatan2WithCheck(IkReal(((((-1.0)*r20*sj5*x1864))+(((-1.0)*cj5*r21*x1864)))),IkReal(((((-1.0)*cj4*r21*sj5*x1864))+((cj4*cj5*r20*sj0))+((r22*sj0*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1866.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1865.value)))+(x1866.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1867=IKsin(j3);
IkReal x1868=IKcos(j3);
IkReal x1869=((1.0)*cj5);
IkReal x1870=(cj4*x1867);
IkReal x1871=((1.0)*sj5*x1868);
IkReal x1872=((1.0)*sj4*x1867);
evalcond[0]=((((-1.0)*r22*x1872))+(((-1.0)*r20*x1869*x1870))+((r21*sj5*x1870))+(((-1.0)*r20*x1871))+(((-1.0)*r21*x1868*x1869)));
evalcond[1]=(cj0+(((-1.0)*r10*x1871))+(((-1.0)*r10*x1869*x1870))+((r11*sj5*x1870))+(((-1.0)*r12*x1872))+(((-1.0)*r11*x1868*x1869)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r02*x1872))+(((-1.0)*r00*x1871))+(((-1.0)*r01*x1868*x1869))+(((-1.0)*r00*x1869*x1870))+((r01*sj5*x1870)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1873=((0.68)*cj0);
IkReal x1874=((0.68)*sj0);
IkReal x1875=(cj0*cj4);
IkReal x1876=((0.6)*r22);
IkReal x1877=(r21*sj5);
IkReal x1878=(cj4*sj0);
IkReal x1879=(sj0*sj4);
IkReal x1880=((0.12)*r22);
IkReal x1881=(cj5*sj4);
IkReal x1882=((2.28)*cj4);
IkReal x1883=(cj0*sj4);
IkReal x1884=((0.6)*r20);
IkReal x1885=((0.76)*cj4);
IkReal x1886=((1.8)*r22);
IkReal x1887=(cj5*r20);
IkReal x1888=((0.04)*r22);
IkReal x1889=(pz*sj0);
IkReal x1890=(cj0*pz);
IkReal x1891=((12.0)*x1890);
IkReal x1892=(r02*x1882);
IkReal x1893=((12.0)*x1889);
IkReal x1894=(r12*x1882);
IkReal x1895=((0.76)*sj4*sj5);
IkReal x1896=((0.12)*x1887);
IkReal x1897=((2.28)*sj4*sj5);
IkReal x1898=(r01*x1897);
IkReal x1899=((2.28)*r00*x1881);
IkReal x1900=(x1880*x1883);
IkReal x1901=(x1875*x1886);
IkReal x1902=(r11*x1897);
IkReal x1903=(x1879*x1880);
IkReal x1904=((2.28)*r10*x1881);
IkReal x1905=(x1878*x1886);
IkReal x1906=((1.8)*cj0*r20*x1881);
IkReal x1907=((0.12)*x1875*x1877);
IkReal x1908=(x1875*x1896);
IkReal x1909=((1.8)*x1877*x1883);
IkReal x1910=((0.12)*x1877*x1878);
IkReal x1911=((1.8)*x1879*x1887);
IkReal x1912=((1.8)*x1877*x1879);
IkReal x1913=(x1878*x1896);
IkReal x1914=(x1902+x1911+x1910+x1894+x1893);
IkReal x1915=(x1906+x1907+x1898+x1891+x1892);
IkReal x1916=(x1904+x1905+x1903+x1913+x1912);
IkReal x1917=(x1908+x1909+x1900+x1901+x1899);
j1eval[0]=((((1.04166666666667)*(IKabs(((((-1.0)*x1873))+x1915+(((-1.0)*x1917)))))))+(((1.04166666666667)*(IKabs(((((-0.04)*x1875*x1887))+(((-1.0)*x1883*x1888))+(((4.0)*x1890))+((r01*x1895))+(((-0.6)*x1877*x1883))+x1873+((cj0*x1881*x1884))+(((0.04)*x1875*x1877))+(((-1.0)*x1875*x1876))+((r02*x1885))+(((-0.76)*r00*x1881)))))))+(((1.04166666666667)*(IKabs(((((4.0)*x1889))+(((-1.0)*x1879*x1888))+(((-1.0)*x1876*x1878))+((r12*x1885))+((r11*x1895))+(((-0.6)*x1877*x1879))+((cj5*x1879*x1884))+x1874+(((0.04)*x1877*x1878))+(((-0.04)*x1878*x1887))+(((-0.76)*r10*x1881)))))))+(((1.04166666666667)*(IKabs(((((-1.0)*x1874))+x1914+(((-1.0)*x1916)))))))+(IKabs(cj0))+(((1.04166666666667)*(IKabs((x1914+x1874+(((-1.0)*x1916)))))))+(IKabs(sj0))+(((1.04166666666667)*(IKabs((x1915+x1873+(((-1.0)*x1917))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1918=((0.68)*cj0);
IkReal x1919=((0.6)*cj0);
IkReal x1920=(cj4*r22);
IkReal x1921=(cj5*r20);
IkReal x1922=(sj4*sj5);
IkReal x1923=(r21*sj5);
IkReal x1924=(cj4*r02);
IkReal x1925=((1.8)*cj0);
IkReal x1926=(cj0*pz);
IkReal x1927=((12.0)*x1926);
IkReal x1928=((2.28)*x1924);
IkReal x1929=((-0.24)*cj0);
IkReal x1930=((4.0)*x1926);
IkReal x1931=((0.76)*x1924);
IkReal x1932=((0.12)*cj0*cj4);
IkReal x1933=(cj5*r00*sj4);
IkReal x1934=(cj0*r22*sj4);
IkReal x1935=((0.04)*cj0*cj4);
IkReal x1936=((2.28)*r01*x1922);
IkReal x1937=((2.28)*x1933);
IkReal x1938=((0.12)*x1934);
IkReal x1939=(x1920*x1925);
IkReal x1940=((0.76)*r01*x1922);
IkReal x1941=(x1919*x1920);
IkReal x1942=((0.76)*x1933);
IkReal x1943=((0.04)*x1934);
IkReal x1944=(sj4*x1921*x1925);
IkReal x1945=(x1923*x1932);
IkReal x1946=(x1921*x1932);
IkReal x1947=(r21*x1922*x1925);
IkReal x1948=(x1923*x1935);
IkReal x1949=(sj4*x1919*x1921);
IkReal x1950=(r21*x1919*x1922);
IkReal x1951=(x1921*x1935);
IkReal x1952=(x1931+x1930+x1948+x1949+x1940);
IkReal x1953=(x1927+x1928+x1936+x1944+x1945);
IkReal x1954=(x1937+x1939+x1938+x1946+x1947);
IkReal x1955=(x1942+x1943+x1941+x1951+x1950);
op[0]=((((-1.0)*x1955))+x1918+x1952);
op[1]=x1929;
op[2]=((((-1.0)*x1954))+x1918+x1953);
op[3]=((-0.48)*cj0);
op[4]=((((-1.0)*x1954))+x1953+(((-1.0)*x1918)));
op[5]=x1929;
op[6]=((((-1.0)*x1955))+x1952+(((-1.0)*x1918)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1956=((0.68)*sj0);
IkReal x1957=((0.12)*sj0);
IkReal x1958=(cj5*r20);
IkReal x1959=(r22*sj4);
IkReal x1960=(r21*sj5);
IkReal x1961=((0.24)*sj0);
IkReal x1962=(cj4*r12);
IkReal x1963=((0.6)*sj0);
IkReal x1964=(cj4*r22);
IkReal x1965=((0.04)*sj0);
IkReal x1966=(pz*sj0);
IkReal x1967=((12.0)*x1966);
IkReal x1968=((2.28)*x1962);
IkReal x1969=((4.0)*x1966);
IkReal x1970=((0.76)*x1962);
IkReal x1971=(r11*sj4*sj5);
IkReal x1972=((1.8)*sj0*sj4);
IkReal x1973=(cj5*r10*sj4);
IkReal x1974=((2.28)*x1971);
IkReal x1975=(x1957*x1959);
IkReal x1976=((2.28)*x1973);
IkReal x1977=((1.8)*sj0*x1964);
IkReal x1978=((0.76)*x1971);
IkReal x1979=(x1959*x1965);
IkReal x1980=((0.76)*x1973);
IkReal x1981=(x1963*x1964);
IkReal x1982=(cj4*x1957*x1960);
IkReal x1983=(x1958*x1972);
IkReal x1984=(x1960*x1972);
IkReal x1985=(cj4*x1957*x1958);
IkReal x1986=(cj4*x1960*x1965);
IkReal x1987=(sj4*x1958*x1963);
IkReal x1988=(sj4*x1960*x1963);
IkReal x1989=(cj4*x1958*x1965);
IkReal x1990=(x1982+x1983+x1968+x1967+x1974);
IkReal x1991=(x1986+x1987+x1969+x1978+x1970);
IkReal x1992=(x1984+x1985+x1977+x1976+x1975);
IkReal x1993=(x1980+x1981+x1988+x1989+x1979);
j1evalpoly[0]=((((-0.48)*sj0*(htj1*htj1*htj1)))+(((htj1*htj1)*(((((-1.0)*x1956))+x1990+(((-1.0)*x1992))))))+(((-1.0)*x1961*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x1956))+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x1991+x1956+(((-1.0)*x1993))))))+x1991+(((-1.0)*htj1*x1961))+(((-1.0)*x1993))+(((htj1*htj1*htj1*htj1)*((x1990+x1956+(((-1.0)*x1992)))))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1994=((1.0)*cj1);
IkReal x1995=(cj4*r22);
IkReal x1996=(r21*sj5);
IkReal x1997=(cj1*r20);
IkReal x1998=(sj3*sj5);
IkReal x1999=(cj3*sj1);
IkReal x2000=(r22*sj4);
IkReal x2001=((1.0)*sj1);
IkReal x2002=(cj3*cj4);
IkReal x2003=(cj5*r20);
IkReal x2004=(cj5*r21*sj3);
if( IKabs((((cj5*sj4*x1997))+((x1999*x2000))+(((-1.0)*r20*x1998*x2001))+(((-1.0)*sj4*x1994*x1996))+(((-1.0)*x2001*x2004))+(((-1.0)*cj4*x1996*x1999))+(((-1.0)*x1994*x1995))+((cj4*x1999*x2003)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj1*sj4*x2003))+((cj1*x1996*x2002))+(((-1.0)*x1994*x2002*x2003))+(((-1.0)*x1995*x2001))+((x1997*x1998))+(((-1.0)*sj4*x1996*x2001))+((cj1*x2004))+(((-1.0)*cj3*x1994*x2000)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj5*sj4*x1997))+((x1999*x2000))+(((-1.0)*r20*x1998*x2001))+(((-1.0)*sj4*x1994*x1996))+(((-1.0)*x2001*x2004))+(((-1.0)*cj4*x1996*x1999))+(((-1.0)*x1994*x1995))+((cj4*x1999*x2003))))+IKsqr((((sj1*sj4*x2003))+((cj1*x1996*x2002))+(((-1.0)*x1994*x2002*x2003))+(((-1.0)*x1995*x2001))+((x1997*x1998))+(((-1.0)*sj4*x1996*x2001))+((cj1*x2004))+(((-1.0)*cj3*x1994*x2000))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj5*sj4*x1997))+((x1999*x2000))+(((-1.0)*r20*x1998*x2001))+(((-1.0)*sj4*x1994*x1996))+(((-1.0)*x2001*x2004))+(((-1.0)*cj4*x1996*x1999))+(((-1.0)*x1994*x1995))+((cj4*x1999*x2003))), (((sj1*sj4*x2003))+((cj1*x1996*x2002))+(((-1.0)*x1994*x2002*x2003))+(((-1.0)*x1995*x2001))+((x1997*x1998))+(((-1.0)*sj4*x1996*x2001))+((cj1*x2004))+(((-1.0)*cj3*x1994*x2000))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x2005=IKcos(j2);
IkReal x2006=IKsin(j2);
IkReal x2007=(cj1*sj0);
IkReal x2008=((1.0)*cj3);
IkReal x2009=(r02*sj4);
IkReal x2010=(cj4*cj5);
IkReal x2011=(r12*sj4);
IkReal x2012=(r01*sj5);
IkReal x2013=((1.0)*sj4);
IkReal x2014=(cj0*cj1);
IkReal x2015=(cj5*sj3);
IkReal x2016=(sj0*sj1);
IkReal x2017=(sj3*sj5);
IkReal x2018=(cj5*sj4);
IkReal x2019=((1.0)*cj4);
IkReal x2020=(cj0*sj1);
IkReal x2021=((0.01)*cj4);
IkReal x2022=(r21*sj5);
IkReal x2023=(r11*sj5);
IkReal x2024=(r22*sj4);
IkReal x2025=((0.15)*x2005);
IkReal x2026=(cj3*cj4*sj5);
IkReal x2027=((1.0)*x2005);
IkReal x2028=(sj1*x2006);
IkReal x2029=((1.0)*x2006);
IkReal x2030=((0.19)*x2005);
IkReal x2031=((0.19)*x2006);
evalcond[0]=(((r20*x2018))+(((-1.0)*cj1*x2029))+(((-1.0)*x2013*x2022))+(((-1.0)*sj1*x2027))+(((-1.0)*r22*x2019)));
evalcond[1]=(((r00*x2018))+((x2005*x2014))+(((-1.0)*x2012*x2013))+(((-1.0)*r02*x2019))+(((-1.0)*x2020*x2029)));
evalcond[2]=((((-1.0)*x2016*x2029))+((r10*x2018))+(((-1.0)*x2013*x2023))+(((-1.0)*r12*x2019))+((x2005*x2007)));
evalcond[3]=(((cj3*cj4*x2022))+((r20*x2017))+x2028+(((-1.0)*r20*x2008*x2010))+(((-1.0)*cj1*x2027))+(((-1.0)*x2008*x2024))+((r21*x2015)));
evalcond[4]=(((r00*x2017))+((r01*x2015))+(((-1.0)*x2008*x2009))+(((-1.0)*x2014*x2029))+((cj3*cj4*x2012))+(((-1.0)*x2020*x2027))+(((-1.0)*r00*x2008*x2010)));
evalcond[5]=(((cj3*cj4*x2023))+(((-1.0)*x2008*x2011))+(((-1.0)*x2016*x2027))+((r10*x2017))+(((-1.0)*r10*x2008*x2010))+(((-1.0)*x2007*x2029))+((r11*x2015)));
evalcond[6]=((((-1.0)*x2021*x2022))+(((0.17)*cj1))+(((0.03)*sj1))+(((0.01)*x2024))+(((-0.15)*cj1*x2006))+(((-1.0)*cj1*x2030))+(((0.01)*r20*x2010))+(((-1.0)*pz))+(((-1.0)*sj1*x2025))+(((0.19)*x2028)));
evalcond[7]=((((-1.0)*x2020*x2030))+(((0.01)*x2009))+(((0.01)*r00*x2010))+(((-0.03)*x2014))+(((0.03)*cj0))+(((-0.15)*x2006*x2020))+(((-1.0)*px))+(((0.17)*x2020))+(((-1.0)*x2014*x2031))+((x2014*x2025))+(((-1.0)*x2012*x2021)));
evalcond[8]=((((-1.0)*x2016*x2030))+(((-1.0)*x2021*x2023))+(((-0.15)*x2006*x2016))+(((0.03)*sj0))+(((0.17)*x2016))+(((0.01)*x2011))+(((-1.0)*x2007*x2031))+((x2007*x2025))+(((-1.0)*py))+(((-0.03)*x2007))+(((0.01)*r10*x2010)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x2032=((1.0)*cj0);
CheckValue<IkReal> x2033=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r02))+((cj5*r00*sj4))+(((-1.0)*r01*sj4*sj5)))),-1);
if(!x2033.valid){
continue;
}
CheckValue<IkReal> x2034 = IKatan2WithCheck(IkReal(((((-1.0)*r20*sj5*x2032))+(((-1.0)*cj5*r21*x2032)))),IkReal(((((-1.0)*cj4*r21*sj5*x2032))+((cj0*cj4*cj5*r20))+((cj0*r22*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x2034.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x2033.value)))+(x2034.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x2035=IKsin(j3);
IkReal x2036=IKcos(j3);
IkReal x2037=((1.0)*cj5);
IkReal x2038=(cj4*x2035);
IkReal x2039=((1.0)*sj5*x2036);
IkReal x2040=((1.0)*sj4*x2035);
evalcond[0]=(((r21*sj5*x2038))+(((-1.0)*r22*x2040))+(((-1.0)*r21*x2036*x2037))+(((-1.0)*r20*x2037*x2038))+(((-1.0)*r20*x2039)));
evalcond[1]=((((-1.0)*r10*x2037*x2038))+cj0+(((-1.0)*r10*x2039))+(((-1.0)*r11*x2036*x2037))+((r11*sj5*x2038))+(((-1.0)*r12*x2040)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r02*x2040))+(((-1.0)*r00*x2037*x2038))+(((-1.0)*r00*x2039))+(((-1.0)*r01*x2036*x2037))+((r01*sj5*x2038)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x2041=((0.68)*cj0);
IkReal x2042=((0.68)*sj0);
IkReal x2043=(cj0*cj4);
IkReal x2044=((0.6)*r22);
IkReal x2045=(r21*sj5);
IkReal x2046=(cj4*sj0);
IkReal x2047=(sj0*sj4);
IkReal x2048=((0.12)*r22);
IkReal x2049=(cj5*sj4);
IkReal x2050=((2.28)*cj4);
IkReal x2051=(cj0*sj4);
IkReal x2052=((0.6)*r20);
IkReal x2053=((0.76)*cj4);
IkReal x2054=((1.8)*r22);
IkReal x2055=(cj5*r20);
IkReal x2056=((0.04)*r22);
IkReal x2057=(pz*sj0);
IkReal x2058=(cj0*pz);
IkReal x2059=((12.0)*x2058);
IkReal x2060=(r02*x2050);
IkReal x2061=((12.0)*x2057);
IkReal x2062=(r12*x2050);
IkReal x2063=((0.76)*sj4*sj5);
IkReal x2064=((0.12)*x2055);
IkReal x2065=((2.28)*sj4*sj5);
IkReal x2066=(r01*x2065);
IkReal x2067=((2.28)*r00*x2049);
IkReal x2068=(x2048*x2051);
IkReal x2069=(x2043*x2054);
IkReal x2070=(r11*x2065);
IkReal x2071=(x2047*x2048);
IkReal x2072=((2.28)*r10*x2049);
IkReal x2073=(x2046*x2054);
IkReal x2074=((1.8)*cj0*r20*x2049);
IkReal x2075=((0.12)*x2043*x2045);
IkReal x2076=(x2043*x2064);
IkReal x2077=((1.8)*x2045*x2051);
IkReal x2078=((0.12)*x2045*x2046);
IkReal x2079=((1.8)*x2047*x2055);
IkReal x2080=((1.8)*x2045*x2047);
IkReal x2081=(x2046*x2064);
IkReal x2082=(x2061+x2062+x2079+x2078+x2070);
IkReal x2083=(x2060+x2066+x2075+x2074+x2059);
IkReal x2084=(x2073+x2072+x2071+x2080+x2081);
IkReal x2085=(x2068+x2069+x2067+x2077+x2076);
j1eval[0]=((((1.04166666666667)*(IKabs(((((-1.0)*x2042))+x2082+(((-1.0)*x2084)))))))+(((1.04166666666667)*(IKabs(((((-1.0)*x2041))+x2083+(((-1.0)*x2085)))))))+(((1.04166666666667)*(IKabs((x2041+x2083+(((-1.0)*x2085)))))))+(((1.04166666666667)*(IKabs((x2042+x2082+(((-1.0)*x2084)))))))+(IKabs(cj0))+(IKabs(sj0))+(((1.04166666666667)*(IKabs(((((-0.04)*x2043*x2055))+(((0.04)*x2043*x2045))+(((-0.6)*x2045*x2051))+x2041+(((-0.76)*r00*x2049))+((r02*x2053))+(((-1.0)*x2051*x2056))+((r01*x2063))+(((-1.0)*x2043*x2044))+((cj0*x2049*x2052))+(((4.0)*x2058)))))))+(((1.04166666666667)*(IKabs((((r12*x2053))+(((-0.6)*x2045*x2047))+(((0.04)*x2045*x2046))+x2042+((cj5*x2047*x2052))+(((-1.0)*x2044*x2046))+((r11*x2063))+(((-0.04)*x2046*x2055))+(((-0.76)*r10*x2049))+(((-1.0)*x2047*x2056))+(((4.0)*x2057))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x2086=((0.68)*cj0);
IkReal x2087=((0.6)*cj0);
IkReal x2088=(cj4*r22);
IkReal x2089=(cj5*r20);
IkReal x2090=(sj4*sj5);
IkReal x2091=(r21*sj5);
IkReal x2092=(cj4*r02);
IkReal x2093=((1.8)*cj0);
IkReal x2094=(cj0*pz);
IkReal x2095=((12.0)*x2094);
IkReal x2096=((2.28)*x2092);
IkReal x2097=((-0.24)*cj0);
IkReal x2098=((4.0)*x2094);
IkReal x2099=((0.76)*x2092);
IkReal x2100=((0.12)*cj0*cj4);
IkReal x2101=(cj5*r00*sj4);
IkReal x2102=(cj0*r22*sj4);
IkReal x2103=((0.04)*cj0*cj4);
IkReal x2104=((2.28)*r01*x2090);
IkReal x2105=((2.28)*x2101);
IkReal x2106=((0.12)*x2102);
IkReal x2107=(x2088*x2093);
IkReal x2108=((0.76)*r01*x2090);
IkReal x2109=(x2087*x2088);
IkReal x2110=((0.76)*x2101);
IkReal x2111=((0.04)*x2102);
IkReal x2112=(sj4*x2089*x2093);
IkReal x2113=(x2091*x2100);
IkReal x2114=(x2089*x2100);
IkReal x2115=(r21*x2090*x2093);
IkReal x2116=(x2091*x2103);
IkReal x2117=(sj4*x2087*x2089);
IkReal x2118=(r21*x2087*x2090);
IkReal x2119=(x2089*x2103);
IkReal x2120=(x2099+x2098+x2116+x2117+x2108);
IkReal x2121=(x2095+x2096+x2112+x2113+x2104);
IkReal x2122=(x2114+x2115+x2107+x2106+x2105);
IkReal x2123=(x2118+x2119+x2110+x2111+x2109);
op[0]=(x2086+x2120+(((-1.0)*x2123)));
op[1]=x2097;
op[2]=(x2086+x2121+(((-1.0)*x2122)));
op[3]=((-0.48)*cj0);
op[4]=((((-1.0)*x2086))+x2121+(((-1.0)*x2122)));
op[5]=x2097;
op[6]=((((-1.0)*x2086))+x2120+(((-1.0)*x2123)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x2124=((0.68)*sj0);
IkReal x2125=((0.12)*sj0);
IkReal x2126=(cj5*r20);
IkReal x2127=(r22*sj4);
IkReal x2128=(r21*sj5);
IkReal x2129=((0.24)*sj0);
IkReal x2130=(cj4*r12);
IkReal x2131=((0.6)*sj0);
IkReal x2132=(cj4*r22);
IkReal x2133=((0.04)*sj0);
IkReal x2134=(pz*sj0);
IkReal x2135=((12.0)*x2134);
IkReal x2136=((2.28)*x2130);
IkReal x2137=((4.0)*x2134);
IkReal x2138=((0.76)*x2130);
IkReal x2139=(r11*sj4*sj5);
IkReal x2140=((1.8)*sj0*sj4);
IkReal x2141=(cj5*r10*sj4);
IkReal x2142=((2.28)*x2139);
IkReal x2143=(x2125*x2127);
IkReal x2144=((2.28)*x2141);
IkReal x2145=((1.8)*sj0*x2132);
IkReal x2146=((0.76)*x2139);
IkReal x2147=(x2127*x2133);
IkReal x2148=((0.76)*x2141);
IkReal x2149=(x2131*x2132);
IkReal x2150=(cj4*x2125*x2128);
IkReal x2151=(x2126*x2140);
IkReal x2152=(x2128*x2140);
IkReal x2153=(cj4*x2125*x2126);
IkReal x2154=(cj4*x2128*x2133);
IkReal x2155=(sj4*x2126*x2131);
IkReal x2156=(sj4*x2128*x2131);
IkReal x2157=(cj4*x2126*x2133);
IkReal x2158=(x2136+x2135+x2150+x2151+x2142);
IkReal x2159=(x2137+x2138+x2154+x2155+x2146);
IkReal x2160=(x2152+x2153+x2145+x2144+x2143);
IkReal x2161=(x2156+x2157+x2147+x2149+x2148);
j1evalpoly[0]=((((htj1*htj1*htj1*htj1)*((x2124+x2158+(((-1.0)*x2160))))))+(((-0.48)*sj0*(htj1*htj1*htj1)))+(((-1.0)*x2129*(htj1*htj1*htj1*htj1*htj1)))+x2159+(((-1.0)*x2124))+(((-1.0)*x2161))+(((htj1*htj1)*((x2158+(((-1.0)*x2124))+(((-1.0)*x2160))))))+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x2124+x2159+(((-1.0)*x2161))))))+(((-1.0)*htj1*x2129)));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x2162=((1.0)*cj1);
IkReal x2163=(cj4*r22);
IkReal x2164=(r21*sj5);
IkReal x2165=(cj1*r20);
IkReal x2166=(sj3*sj5);
IkReal x2167=(cj3*sj1);
IkReal x2168=(r22*sj4);
IkReal x2169=((1.0)*sj1);
IkReal x2170=(cj3*cj4);
IkReal x2171=(cj5*r20);
IkReal x2172=(cj5*r21*sj3);
if( IKabs(((((-1.0)*x2169*x2172))+(((-1.0)*cj4*x2164*x2167))+((cj4*x2167*x2171))+((x2167*x2168))+(((-1.0)*r20*x2166*x2169))+((cj5*sj4*x2165))+(((-1.0)*x2162*x2163))+(((-1.0)*sj4*x2162*x2164)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj4*x2164*x2169))+(((-1.0)*x2163*x2169))+((x2165*x2166))+((sj1*sj4*x2171))+((cj1*x2164*x2170))+(((-1.0)*x2162*x2170*x2171))+((cj1*x2172))+(((-1.0)*cj3*x2162*x2168)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x2169*x2172))+(((-1.0)*cj4*x2164*x2167))+((cj4*x2167*x2171))+((x2167*x2168))+(((-1.0)*r20*x2166*x2169))+((cj5*sj4*x2165))+(((-1.0)*x2162*x2163))+(((-1.0)*sj4*x2162*x2164))))+IKsqr(((((-1.0)*sj4*x2164*x2169))+(((-1.0)*x2163*x2169))+((x2165*x2166))+((sj1*sj4*x2171))+((cj1*x2164*x2170))+(((-1.0)*x2162*x2170*x2171))+((cj1*x2172))+(((-1.0)*cj3*x2162*x2168))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x2169*x2172))+(((-1.0)*cj4*x2164*x2167))+((cj4*x2167*x2171))+((x2167*x2168))+(((-1.0)*r20*x2166*x2169))+((cj5*sj4*x2165))+(((-1.0)*x2162*x2163))+(((-1.0)*sj4*x2162*x2164))), ((((-1.0)*sj4*x2164*x2169))+(((-1.0)*x2163*x2169))+((x2165*x2166))+((sj1*sj4*x2171))+((cj1*x2164*x2170))+(((-1.0)*x2162*x2170*x2171))+((cj1*x2172))+(((-1.0)*cj3*x2162*x2168))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x2173=IKcos(j2);
IkReal x2174=IKsin(j2);
IkReal x2175=(cj1*sj0);
IkReal x2176=((1.0)*cj3);
IkReal x2177=(r02*sj4);
IkReal x2178=(cj4*cj5);
IkReal x2179=(r12*sj4);
IkReal x2180=(r01*sj5);
IkReal x2181=((1.0)*sj4);
IkReal x2182=(cj0*cj1);
IkReal x2183=(cj5*sj3);
IkReal x2184=(sj0*sj1);
IkReal x2185=(sj3*sj5);
IkReal x2186=(cj5*sj4);
IkReal x2187=((1.0)*cj4);
IkReal x2188=(cj0*sj1);
IkReal x2189=((0.01)*cj4);
IkReal x2190=(r21*sj5);
IkReal x2191=(r11*sj5);
IkReal x2192=(r22*sj4);
IkReal x2193=((0.15)*x2173);
IkReal x2194=(cj3*cj4*sj5);
IkReal x2195=((1.0)*x2173);
IkReal x2196=(sj1*x2174);
IkReal x2197=((1.0)*x2174);
IkReal x2198=((0.19)*x2173);
IkReal x2199=((0.19)*x2174);
evalcond[0]=(((r20*x2186))+(((-1.0)*sj1*x2195))+(((-1.0)*r22*x2187))+(((-1.0)*x2181*x2190))+(((-1.0)*cj1*x2197)));
evalcond[1]=((((-1.0)*x2180*x2181))+(((-1.0)*x2188*x2197))+(((-1.0)*r02*x2187))+((x2173*x2182))+((r00*x2186)));
evalcond[2]=(((x2173*x2175))+(((-1.0)*x2181*x2191))+(((-1.0)*x2184*x2197))+(((-1.0)*r12*x2187))+((r10*x2186)));
evalcond[3]=(x2196+((r20*x2185))+(((-1.0)*r20*x2176*x2178))+((cj3*cj4*x2190))+((r21*x2183))+(((-1.0)*cj1*x2195))+(((-1.0)*x2176*x2192)));
evalcond[4]=((((-1.0)*x2176*x2177))+(((-1.0)*x2188*x2195))+((cj3*cj4*x2180))+(((-1.0)*r00*x2176*x2178))+(((-1.0)*x2182*x2197))+((r01*x2183))+((r00*x2185)));
evalcond[5]=((((-1.0)*x2176*x2179))+(((-1.0)*x2175*x2197))+((cj3*cj4*x2191))+(((-1.0)*x2184*x2195))+((r11*x2183))+(((-1.0)*r10*x2176*x2178))+((r10*x2185)));
evalcond[6]=((((0.17)*cj1))+(((0.01)*x2192))+(((0.03)*sj1))+(((-1.0)*x2189*x2190))+(((-1.0)*pz))+(((-1.0)*sj1*x2193))+(((0.19)*x2196))+(((-1.0)*cj1*x2198))+(((-0.15)*cj1*x2174))+(((0.01)*r20*x2178)));
evalcond[7]=((((0.01)*r00*x2178))+(((-1.0)*x2180*x2189))+(((-1.0)*x2188*x2198))+(((0.03)*cj0))+((x2182*x2193))+(((-1.0)*px))+(((0.01)*x2177))+(((0.17)*x2188))+(((-1.0)*x2182*x2199))+(((-0.03)*x2182))+(((-0.15)*x2174*x2188)));
evalcond[8]=((((0.03)*sj0))+(((-1.0)*x2175*x2199))+(((-1.0)*x2189*x2191))+(((-1.0)*py))+(((0.01)*x2179))+(((0.17)*x2184))+((x2175*x2193))+(((-0.03)*x2175))+(((-1.0)*x2184*x2198))+(((-0.15)*x2174*x2184))+(((0.01)*r10*x2178)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - smartduino_6DoF (c4c012dc7ad30ca8ec6f5b27ff5dd4a3)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
